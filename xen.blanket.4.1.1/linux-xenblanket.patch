diff -Nur linux-3.1.2/arch/x86/include/asm/xen/xenblanket.h linux-3.1.2-xenblanket/arch/x86/include/asm/xen/xenblanket.h
--- linux-3.1.2/arch/x86/include/asm/xen/xenblanket.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.1.2-xenblanket/arch/x86/include/asm/xen/xenblanket.h	2012-03-02 17:54:11.000000000 -0500
@@ -0,0 +1,16 @@
+#ifndef XENBLANKET
+#define XENBLANKET
+
+#define __HYPERVISOR_blanket_get_cpuid    39
+#define __HYPERVISOR_blanket_init_nested_hypercall      40      /* 40 */
+#define __HYPERVISOR_blanket_xen_version                41               
+#define __HYPERVISOR_blanket_memory_op                  42                 
+#define __HYPERVISOR_blanket_hvm_op                     43                   
+#define __HYPERVISOR_blanket_grant_table_op             44           
+#define __HYPERVISOR_blanket_event_channel_op           45      /* 45 */
+#define __HYPERVISOR_blanket_sched_op                   46
+
+extern int xenblanket_platform;
+extern struct shared_info *HYPERVISOR_shared_info_hvm;
+
+#endif
diff -Nur linux-3.1.2/arch/x86/include/asm/xen/xenblanket_hypercall.h linux-3.1.2-xenblanket/arch/x86/include/asm/xen/xenblanket_hypercall.h
--- linux-3.1.2/arch/x86/include/asm/xen/xenblanket_hypercall.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.1.2-xenblanket/arch/x86/include/asm/xen/xenblanket_hypercall.h	2012-03-02 17:54:11.000000000 -0500
@@ -0,0 +1,65 @@
+#ifndef _ASM_X86_XENBLANKET_HYPERCALL_H
+#define _ASM_X86_XENBLANKET_HYPERCALL_H
+
+#include "xenblanket.h"
+
+struct blanket_get_cpuid {
+    uint32_t eax;
+    uint32_t ebx;
+    uint32_t ecx;
+    uint32_t edx;
+};
+
+
+static inline long
+HYPERVISOR_blanket_get_cpuid(
+        uint32_t base,
+        struct blanket_get_cpuid *arg)
+{
+        return _hypercall2(long, blanket_get_cpuid, base, arg);
+}
+
+static inline long
+HYPERVISOR_blanket_init_nested_hypercall(void)
+{
+        return _hypercall0(long, blanket_init_nested_hypercall);
+}
+
+static inline long
+HYPERVISOR_blanket_xen_version(int cmd, void *arg)
+{
+        return _hypercall2(long, blanket_xen_version, cmd, arg);
+}
+
+static inline long
+HYPERVISOR_blanket_grant_table_op(unsigned int cmd, void *uop, unsigned int count)
+{
+        return _hypercall3(long, blanket_grant_table_op, cmd, uop, count);
+}
+
+static inline long
+HYPERVISOR_blanket_memory_op(unsigned int cmd, void *arg)
+{
+        return _hypercall2(long, blanket_memory_op, cmd, arg);
+}
+
+static inline long
+HYPERVISOR_blanket_hvm_op(int op, void *arg)
+{
+       return _hypercall2(long, blanket_hvm_op, op, arg);
+}
+
+static inline long
+HYPERVISOR_blanket_event_channel_op(int cmd, void *arg)
+{
+        return _hypercall2(long, blanket_event_channel_op, cmd, arg);
+}
+
+static inline long
+HYPERVISOR_blanket_sched_op(int cmd, void *arg)
+{
+        return _hypercall2(long, blanket_sched_op, cmd, arg);
+}
+
+#endif
+
diff -Nur linux-3.1.2/drivers/Makefile linux-3.1.2-xenblanket/drivers/Makefile
--- linux-3.1.2/drivers/Makefile	2011-11-21 17:47:46.000000000 -0500
+++ linux-3.1.2-xenblanket/drivers/Makefile	2012-03-02 20:11:58.000000000 -0500
@@ -23,6 +23,7 @@
 
 obj-$(CONFIG_VIRTIO)		+= virtio/
 obj-$(CONFIG_XEN)		+= xen/
+obj-y				+= xen-blanket/
 
 # regulators early, since some subsystems rely on them to initialize
 obj-$(CONFIG_REGULATOR)		+= regulator/
diff -Nur linux-3.1.2/drivers/xen-blanket/Makefile linux-3.1.2-xenblanket/drivers/xen-blanket/Makefile
--- linux-3.1.2/drivers/xen-blanket/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/Makefile	2012-03-02 20:28:44.000000000 -0500
@@ -0,0 +1,3 @@
+obj-y += xenblanket_platform.o grant-table.o features.o events.o manage.o platform-pci-unplug.o platform-pci.o
+obj-y += xenbus/
+obj-y += xendev/
diff -Nur linux-3.1.2/drivers/xen-blanket/biomerge.c linux-3.1.2-xenblanket/drivers/xen-blanket/biomerge.c
--- linux-3.1.2/drivers/xen-blanket/biomerge.c	2012-04-09 05:27:46.545422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/biomerge.c	2012-03-02 20:28:43.000000000 -0500
@@ -2,7 +2,7 @@
 #include <linux/io.h>
 #include <xen/page.h>
 
-bool xen_biovec_phys_mergeable(const struct bio_vec *vec1,
+bool xen_biovec_phys_mergeable_hvm(const struct bio_vec *vec1,
 			       const struct bio_vec *vec2)
 {
 	unsigned long mfn1 = pfn_to_mfn(page_to_pfn(vec1->bv_page));
diff -Nur linux-3.1.2/drivers/xen-blanket/events.c linux-3.1.2-xenblanket/drivers/xen-blanket/events.c
--- linux-3.1.2/drivers/xen-blanket/events.c	2012-04-09 05:27:46.601422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/events.c	2012-04-09 06:30:31.209422002 -0400
@@ -44,17 +44,22 @@
 #include <xen/xen.h>
 #include <xen/hvm.h>
 #include <xen/xen-ops.h>
-#include <xen/events.h>
+#include "events.h"
 #include <xen/interface/xen.h>
 #include <xen/interface/event_channel.h>
 #include <xen/interface/hvm/hvm_op.h>
 #include <xen/interface/hvm/params.h>
 
+#include "xenblanket.h"
+#include "xenblanket_hypercall.h"
+
 /*
  * This lock protects updates to the following mapping and reference-count
  * arrays. The lock does not need to be acquired to read the mapping tables.
  */
-static DEFINE_MUTEX(irq_mapping_update_lock);
+static int xenblanket_irq_initialized = 0;
+
+static DEFINE_SPINLOCK(irq_mapping_update_lock);
 
 static LIST_HEAD(xen_irq_list_head);
 
@@ -212,11 +217,11 @@
 	return info_for_irq(irq)->evtchn;
 }
 
-unsigned irq_from_evtchn(unsigned int evtchn)
+unsigned irq_from_evtchn_hvm(unsigned int evtchn)
 {
 	return evtchn_to_irq[evtchn];
 }
-EXPORT_SYMBOL_GPL(irq_from_evtchn);
+EXPORT_SYMBOL_GPL(irq_from_evtchn_hvm);
 
 static enum ipi_vector ipi_from_irq(unsigned irq)
 {
@@ -322,19 +327,19 @@
 
 static inline void clear_evtchn(int port)
 {
-	struct shared_info *s = HYPERVISOR_shared_info;
+	struct shared_info *s = HYPERVISOR_shared_info_hvm;
 	sync_clear_bit(port, &s->evtchn_pending[0]);
 }
 
 static inline void set_evtchn(int port)
 {
-	struct shared_info *s = HYPERVISOR_shared_info;
+	struct shared_info *s = HYPERVISOR_shared_info_hvm;
 	sync_set_bit(port, &s->evtchn_pending[0]);
 }
 
 static inline int test_evtchn(int port)
 {
-	struct shared_info *s = HYPERVISOR_shared_info;
+	struct shared_info *s = HYPERVISOR_shared_info_hvm;
 	return sync_test_bit(port, &s->evtchn_pending[0]);
 }
 
@@ -347,24 +352,24 @@
  * save/restore. Notifications on a broken connection are silently
  * dropped.
  */
-void notify_remote_via_irq(int irq)
+void notify_remote_via_irq_hvm(int irq)
 {
 	int evtchn = evtchn_from_irq(irq);
 
 	if (VALID_EVTCHN(evtchn))
-		notify_remote_via_evtchn(evtchn);
+		notify_remote_via_evtchn_hvm(evtchn);
 }
-EXPORT_SYMBOL_GPL(notify_remote_via_irq);
+EXPORT_SYMBOL_GPL(notify_remote_via_irq_hvm);
 
 static void mask_evtchn(int port)
 {
-	struct shared_info *s = HYPERVISOR_shared_info;
+	struct shared_info *s = HYPERVISOR_shared_info_hvm;
 	sync_set_bit(port, &s->evtchn_mask[0]);
 }
 
 static void unmask_evtchn(int port)
 {
-	struct shared_info *s = HYPERVISOR_shared_info;
+	struct shared_info *s = HYPERVISOR_shared_info_hvm;
 	unsigned int cpu = get_cpu();
 
 	BUG_ON(!irqs_disabled());
@@ -372,7 +377,7 @@
 	/* Slow path (hypercall) if this is a non-local port. */
 	if (unlikely(cpu != cpu_from_evtchn(port))) {
 		struct evtchn_unmask unmask = { .port = port };
-		(void)HYPERVISOR_event_channel_op(EVTCHNOP_unmask, &unmask);
+		(void)HYPERVISOR_blanket_event_channel_op(EVTCHNOP_unmask, &unmask);
 	} else {
 		struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);
 
@@ -540,7 +545,7 @@
 	/* NB. We are happy to share unless we are probing. */
 	bind_pirq.flags = info->u.pirq.flags & PIRQ_SHAREABLE ?
 					BIND_PIRQ__WILL_SHARE : 0;
-	rc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_pirq, &bind_pirq);
+	rc = HYPERVISOR_blanket_event_channel_op(EVTCHNOP_bind_pirq, &bind_pirq);
 	if (rc != 0) {
 		if (!probing_irq(irq))
 			printk(KERN_INFO "Failed to obtain physical IRQ %d\n",
@@ -582,7 +587,7 @@
 	mask_evtchn(evtchn);
 
 	close.port = evtchn;
-	if (HYPERVISOR_event_channel_op(EVTCHNOP_close, &close) != 0)
+	if (HYPERVISOR_blanket_event_channel_op(EVTCHNOP_close, &close) != 0)
 		BUG();
 
 	bind_evtchn_to_cpu(evtchn, 0);
@@ -625,13 +630,13 @@
  * Shareable implies level triggered, not shareable implies edge
  * triggered here.
  */
-int xen_bind_pirq_gsi_to_irq(unsigned gsi,
+int xen_bind_pirq_gsi_to_irq_hvm(unsigned gsi,
 			     unsigned pirq, int shareable, char *name)
 {
 	int irq = -1;
 	struct physdev_irq irq_op;
 
-	mutex_lock(&irq_mapping_update_lock);
+	spin_lock(&irq_mapping_update_lock);
 
 	irq = find_irq_by_gsi(gsi);
 	if (irq != -1) {
@@ -684,13 +689,13 @@
 				handle_edge_irq, name);
 
 out:
-	mutex_unlock(&irq_mapping_update_lock);
+	spin_unlock(&irq_mapping_update_lock);
 
 	return irq;
 }
 
 #ifdef CONFIG_PCI_MSI
-int xen_allocate_pirq_msi(struct pci_dev *dev, struct msi_desc *msidesc)
+int xen_allocate_pirq_msi_hvm(struct pci_dev *dev, struct msi_desc *msidesc)
 {
 	int rc;
 	struct physdev_get_free_pirq op_get_free_pirq;
@@ -704,13 +709,13 @@
 	return rc ? -1 : op_get_free_pirq.pirq;
 }
 
-int xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,
+int xen_bind_pirq_msi_to_irq_hvm(struct pci_dev *dev, struct msi_desc *msidesc,
 			     int pirq, int vector, const char *name,
 			     domid_t domid)
 {
 	int irq, ret;
 
-	mutex_lock(&irq_mapping_update_lock);
+	spin_lock(&irq_mapping_update_lock);
 
 	irq = xen_allocate_irq_dynamic();
 	if (irq == -1)
@@ -724,23 +729,23 @@
 	if (ret < 0)
 		goto error_irq;
 out:
-	mutex_unlock(&irq_mapping_update_lock);
+	spin_unlock(&irq_mapping_update_lock);
 	return irq;
 error_irq:
-	mutex_unlock(&irq_mapping_update_lock);
+	spin_unlock(&irq_mapping_update_lock);
 	xen_free_irq(irq);
 	return -1;
 }
 #endif
 
-int xen_destroy_irq(int irq)
+int xen_destroy_irq_hvm(int irq)
 {
 	struct irq_desc *desc;
 	struct physdev_unmap_pirq unmap_irq;
 	struct irq_info *info = info_for_irq(irq);
 	int rc = -ENOENT;
 
-	mutex_lock(&irq_mapping_update_lock);
+	spin_lock(&irq_mapping_update_lock);
 
 	desc = irq_to_desc(irq);
 	if (!desc)
@@ -766,17 +771,17 @@
 	xen_free_irq(irq);
 
 out:
-	mutex_unlock(&irq_mapping_update_lock);
+	spin_unlock(&irq_mapping_update_lock);
 	return rc;
 }
 
-int xen_irq_from_pirq(unsigned pirq)
+int xen_irq_from_pirq_hvm(unsigned pirq)
 {
 	int irq;
 
 	struct irq_info *info;
 
-	mutex_lock(&irq_mapping_update_lock);
+	spin_lock(&irq_mapping_update_lock);
 
 	list_for_each_entry(info, &xen_irq_list_head, list) {
 		if (info == NULL || info->type != IRQT_PIRQ)
@@ -787,49 +792,50 @@
 	}
 	irq = -1;
 out:
-	mutex_unlock(&irq_mapping_update_lock);
+	spin_unlock(&irq_mapping_update_lock);
 
 	return irq;
 }
 
 
-int xen_pirq_from_irq(unsigned irq)
+int xen_pirq_from_irq_hvm(unsigned irq)
 {
 	return pirq_from_irq(irq);
 }
-EXPORT_SYMBOL_GPL(xen_pirq_from_irq);
-int bind_evtchn_to_irq(unsigned int evtchn)
+EXPORT_SYMBOL_GPL(xen_pirq_from_irq_hvm);
+int bind_evtchn_to_irq_hvm(unsigned int evtchn)
 {
 	int irq;
 
-	mutex_lock(&irq_mapping_update_lock);
+	spin_lock(&irq_mapping_update_lock);
 
 	irq = evtchn_to_irq[evtchn];
 
 	if (irq == -1) {
+
 		irq = xen_allocate_irq_dynamic();
 		if (irq == -1)
 			goto out;
 
 		irq_set_chip_and_handler_name(irq, &xen_dynamic_chip,
-					      handle_edge_irq, "event");
+					      handle_edge_irq, "xenblanket_event");
 
 		xen_irq_info_evtchn_init(irq, evtchn);
 	}
 
 out:
-	mutex_unlock(&irq_mapping_update_lock);
+	spin_unlock(&irq_mapping_update_lock);
 
 	return irq;
 }
-EXPORT_SYMBOL_GPL(bind_evtchn_to_irq);
+EXPORT_SYMBOL_GPL(bind_evtchn_to_irq_hvm);
 
 static int bind_ipi_to_irq(unsigned int ipi, unsigned int cpu)
 {
 	struct evtchn_bind_ipi bind_ipi;
 	int evtchn, irq;
 
-	mutex_lock(&irq_mapping_update_lock);
+	spin_lock(&irq_mapping_update_lock);
 
 	irq = per_cpu(ipi_to_irq, cpu)[ipi];
 
@@ -842,7 +848,7 @@
 					      handle_percpu_irq, "ipi");
 
 		bind_ipi.vcpu = cpu;
-		if (HYPERVISOR_event_channel_op(EVTCHNOP_bind_ipi,
+		if (HYPERVISOR_blanket_event_channel_op(EVTCHNOP_bind_ipi,
 						&bind_ipi) != 0)
 			BUG();
 		evtchn = bind_ipi.port;
@@ -853,7 +859,7 @@
 	}
 
  out:
-	mutex_unlock(&irq_mapping_update_lock);
+	spin_unlock(&irq_mapping_update_lock);
 	return irq;
 }
 
@@ -866,19 +872,19 @@
 	bind_interdomain.remote_dom  = remote_domain;
 	bind_interdomain.remote_port = remote_port;
 
-	err = HYPERVISOR_event_channel_op(EVTCHNOP_bind_interdomain,
+	err = HYPERVISOR_blanket_event_channel_op(EVTCHNOP_bind_interdomain,
 					  &bind_interdomain);
 
-	return err ? : bind_evtchn_to_irq(bind_interdomain.local_port);
+	return err ? : bind_evtchn_to_irq_hvm(bind_interdomain.local_port);
 }
 
 
-int bind_virq_to_irq(unsigned int virq, unsigned int cpu)
+int bind_virq_to_irq_hvm(unsigned int virq, unsigned int cpu)
 {
 	struct evtchn_bind_virq bind_virq;
 	int evtchn, irq;
 
-	mutex_lock(&irq_mapping_update_lock);
+	spin_lock(&irq_mapping_update_lock);
 
 	irq = per_cpu(virq_to_irq, cpu)[virq];
 
@@ -892,7 +898,7 @@
 
 		bind_virq.virq = virq;
 		bind_virq.vcpu = cpu;
-		if (HYPERVISOR_event_channel_op(EVTCHNOP_bind_virq,
+		if (HYPERVISOR_blanket_event_channel_op(EVTCHNOP_bind_virq,
 						&bind_virq) != 0)
 			BUG();
 		evtchn = bind_virq.port;
@@ -903,7 +909,7 @@
 	}
 
 out:
-	mutex_unlock(&irq_mapping_update_lock);
+	spin_unlock(&irq_mapping_update_lock);
 
 	return irq;
 }
@@ -913,11 +919,11 @@
 	struct evtchn_close close;
 	int evtchn = evtchn_from_irq(irq);
 
-	mutex_lock(&irq_mapping_update_lock);
+	spin_lock(&irq_mapping_update_lock);
 
 	if (VALID_EVTCHN(evtchn)) {
 		close.port = evtchn;
-		if (HYPERVISOR_event_channel_op(EVTCHNOP_close, &close) != 0)
+		if (HYPERVISOR_blanket_event_channel_op(EVTCHNOP_close, &close) != 0)
 			BUG();
 
 		switch (type_from_irq(irq)) {
@@ -943,17 +949,17 @@
 
 	xen_free_irq(irq);
 
-	mutex_unlock(&irq_mapping_update_lock);
+	spin_unlock(&irq_mapping_update_lock);
 }
 
-int bind_evtchn_to_irqhandler(unsigned int evtchn,
+int bind_evtchn_to_irqhandler_hvm(unsigned int evtchn,
 			      irq_handler_t handler,
 			      unsigned long irqflags,
 			      const char *devname, void *dev_id)
 {
 	int irq, retval;
 
-	irq = bind_evtchn_to_irq(evtchn);
+	irq = bind_evtchn_to_irq_hvm(evtchn);
 	if (irq < 0)
 		return irq;
 	retval = request_irq(irq, handler, irqflags, devname, dev_id);
@@ -964,9 +970,9 @@
 
 	return irq;
 }
-EXPORT_SYMBOL_GPL(bind_evtchn_to_irqhandler);
+EXPORT_SYMBOL_GPL(bind_evtchn_to_irqhandler_hvm);
 
-int bind_interdomain_evtchn_to_irqhandler(unsigned int remote_domain,
+int bind_interdomain_evtchn_to_irqhandler_hvm(unsigned int remote_domain,
 					  unsigned int remote_port,
 					  irq_handler_t handler,
 					  unsigned long irqflags,
@@ -987,15 +993,15 @@
 
 	return irq;
 }
-EXPORT_SYMBOL_GPL(bind_interdomain_evtchn_to_irqhandler);
+EXPORT_SYMBOL_GPL(bind_interdomain_evtchn_to_irqhandler_hvm);
 
-int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
+int bind_virq_to_irqhandler_hvm(unsigned int virq, unsigned int cpu,
 			    irq_handler_t handler,
 			    unsigned long irqflags, const char *devname, void *dev_id)
 {
 	int irq, retval;
 
-	irq = bind_virq_to_irq(virq, cpu);
+	irq = bind_virq_to_irq_hvm(virq, cpu);
 	if (irq < 0)
 		return irq;
 	retval = request_irq(irq, handler, irqflags, devname, dev_id);
@@ -1006,9 +1012,9 @@
 
 	return irq;
 }
-EXPORT_SYMBOL_GPL(bind_virq_to_irqhandler);
+EXPORT_SYMBOL_GPL(bind_virq_to_irqhandler_hvm);
 
-int bind_ipi_to_irqhandler(enum ipi_vector ipi,
+int bind_ipi_to_irqhandler_hvm(enum ipi_vector ipi,
 			   unsigned int cpu,
 			   irq_handler_t handler,
 			   unsigned long irqflags,
@@ -1021,7 +1027,7 @@
 	if (irq < 0)
 		return irq;
 
-	irqflags |= IRQF_NO_SUSPEND | IRQF_FORCE_RESUME | IRQF_EARLY_RESUME;
+	irqflags |= IRQF_NO_SUSPEND | IRQF_FORCE_RESUME;
 	retval = request_irq(irq, handler, irqflags, devname, dev_id);
 	if (retval != 0) {
 		unbind_from_irq(irq);
@@ -1031,23 +1037,23 @@
 	return irq;
 }
 
-void unbind_from_irqhandler(unsigned int irq, void *dev_id)
+void unbind_from_irqhandler_hvm(unsigned int irq, void *dev_id)
 {
 	free_irq(irq, dev_id);
 	unbind_from_irq(irq);
 }
-EXPORT_SYMBOL_GPL(unbind_from_irqhandler);
+EXPORT_SYMBOL_GPL(unbind_from_irqhandler_hvm);
 
-void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector)
+void xen_send_IPI_one_hvm(unsigned int cpu, enum ipi_vector vector)
 {
 	int irq = per_cpu(ipi_to_irq, cpu)[vector];
 	BUG_ON(irq < 0);
-	notify_remote_via_irq(irq);
+	notify_remote_via_irq_hvm(irq);
 }
 
-irqreturn_t xen_debug_interrupt(int irq, void *dev_id)
+irqreturn_t xen_debug_interrupt_hvm(int irq, void *dev_id)
 {
-	struct shared_info *sh = HYPERVISOR_shared_info;
+	struct shared_info *sh = HYPERVISOR_shared_info_hvm;
 	int cpu = smp_processor_id();
 	unsigned long *cpu_evtchn = per_cpu(cpu_evtchn_mask, cpu);
 	int i;
@@ -1144,16 +1150,20 @@
  * a bitset of words which contain pending event bits.  The second
  * level is a bitset of pending events themselves.
  */
-static void __xen_evtchn_do_upcall(void)
+void __xen_evtchn_do_upcall_hvm(void)
 {
 	int start_word_idx, start_bit_idx;
 	int word_idx, bit_idx;
 	int i;
 	int cpu = get_cpu();
-	struct shared_info *s = HYPERVISOR_shared_info;
-	struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);
+	struct shared_info *s = HYPERVISOR_shared_info_hvm;
+	struct vcpu_info *vcpu_info = &(s->vcpu_info[cpu]);
  	unsigned count;
 
+	if(xenblanket_irq_initialized == 0)
+		return;
+
+
 	do {
 		unsigned long pending_words;
 
@@ -1250,28 +1260,29 @@
 
 	put_cpu();
 }
+EXPORT_SYMBOL_GPL(__xen_evtchn_do_upcall_hvm);
 
-void xen_evtchn_do_upcall(struct pt_regs *regs)
+void xen_evtchn_do_upcall_hvm(struct pt_regs *regs)
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
 	exit_idle();
 	irq_enter();
 
-	__xen_evtchn_do_upcall();
+	__xen_evtchn_do_upcall_hvm();
 
 	irq_exit();
 	set_irq_regs(old_regs);
 }
 
-void xen_hvm_evtchn_do_upcall(void)
+void xen_hvm_evtchn_do_upcall_hvm(void)
 {
-	__xen_evtchn_do_upcall();
+	__xen_evtchn_do_upcall_hvm();
 }
-EXPORT_SYMBOL_GPL(xen_hvm_evtchn_do_upcall);
+EXPORT_SYMBOL_GPL(xen_hvm_evtchn_do_upcall_hvm);
 
 /* Rebind a new event channel to an existing irq. */
-void rebind_evtchn_irq(int evtchn, int irq)
+void rebind_evtchn_irq_hvm(int evtchn, int irq)
 {
 	struct irq_info *info = info_for_irq(irq);
 
@@ -1279,7 +1290,7 @@
 	   will also be masked. */
 	disable_irq(irq);
 
-	mutex_lock(&irq_mapping_update_lock);
+	spin_lock(&irq_mapping_update_lock);
 
 	/* After resume the irq<->evtchn mappings are all cleared out */
 	BUG_ON(evtchn_to_irq[evtchn] != -1);
@@ -1289,7 +1300,7 @@
 
 	xen_irq_info_evtchn_init(irq, evtchn);
 
-	mutex_unlock(&irq_mapping_update_lock);
+	spin_unlock(&irq_mapping_update_lock);
 
 	/* new event channels are always bound to cpu 0 */
 	irq_set_affinity(irq, cpumask_of(0));
@@ -1311,7 +1322,7 @@
 	 * Events delivered via platform PCI interrupts are always
 	 * routed to vcpu 0 and hence cannot be rebound.
 	 */
-	if (xen_hvm_domain() && !xen_have_vector_callback)
+	if (xen_hvm_domain() && !xen_have_vector_callback_hvm)
 		return -1;
 
 	/* Send future instances of this interrupt to other vcpu. */
@@ -1323,7 +1334,7 @@
 	 * virq or IPI channel, which don't actually need to be rebound. Ignore
 	 * it, but don't do the xenlinux-level rebind in that case.
 	 */
-	if (HYPERVISOR_event_channel_op(EVTCHNOP_bind_vcpu, &bind_vcpu) >= 0)
+	if (HYPERVISOR_blanket_event_channel_op(EVTCHNOP_bind_vcpu, &bind_vcpu) >= 0)
 		bind_evtchn_to_cpu(evtchn, tcpu);
 
 	return 0;
@@ -1337,10 +1348,10 @@
 	return rebind_irq_to_cpu(data->irq, tcpu);
 }
 
-int resend_irq_on_evtchn(unsigned int irq)
+int resend_irq_on_evtchn_hvm(unsigned int irq)
 {
 	int masked, evtchn = evtchn_from_irq(irq);
-	struct shared_info *s = HYPERVISOR_shared_info;
+	struct shared_info *s = HYPERVISOR_shared_info_hvm;
 
 	if (!VALID_EVTCHN(evtchn))
 		return 1;
@@ -1388,7 +1399,7 @@
 static int retrigger_dynirq(struct irq_data *data)
 {
 	int evtchn = evtchn_from_irq(data->irq);
-	struct shared_info *sh = HYPERVISOR_shared_info;
+	struct shared_info *sh = HYPERVISOR_shared_info_hvm;
 	int ret = 0;
 
 	if (VALID_EVTCHN(evtchn)) {
@@ -1456,7 +1467,7 @@
 		/* Get a new binding from Xen. */
 		bind_virq.virq = virq;
 		bind_virq.vcpu = cpu;
-		if (HYPERVISOR_event_channel_op(EVTCHNOP_bind_virq,
+		if (HYPERVISOR_blanket_event_channel_op(EVTCHNOP_bind_virq,
 						&bind_virq) != 0)
 			BUG();
 		evtchn = bind_virq.port;
@@ -1480,7 +1491,7 @@
 
 		/* Get a new binding from Xen. */
 		bind_ipi.vcpu = cpu;
-		if (HYPERVISOR_event_channel_op(EVTCHNOP_bind_ipi,
+		if (HYPERVISOR_blanket_event_channel_op(EVTCHNOP_bind_ipi,
 						&bind_ipi) != 0)
 			BUG();
 		evtchn = bind_ipi.port;
@@ -1492,15 +1503,15 @@
 }
 
 /* Clear an irq's pending state, in preparation for polling on it */
-void xen_clear_irq_pending(int irq)
+void xen_clear_irq_pending_hvm(int irq)
 {
 	int evtchn = evtchn_from_irq(irq);
 
 	if (VALID_EVTCHN(evtchn))
 		clear_evtchn(evtchn);
 }
-EXPORT_SYMBOL(xen_clear_irq_pending);
-void xen_set_irq_pending(int irq)
+EXPORT_SYMBOL(xen_clear_irq_pending_hvm);
+void xen_set_irq_pending_hvm(int irq)
 {
 	int evtchn = evtchn_from_irq(irq);
 
@@ -1508,7 +1519,7 @@
 		set_evtchn(evtchn);
 }
 
-bool xen_test_irq_pending(int irq)
+bool xen_test_irq_pending_hvm(int irq)
 {
 	int evtchn = evtchn_from_irq(irq);
 	bool ret = false;
@@ -1521,7 +1532,7 @@
 
 /* Poll waiting for an irq to become pending with timeout.  In the usual case,
  * the irq will be disabled so it won't deliver an interrupt. */
-void xen_poll_irq_timeout(int irq, u64 timeout)
+void xen_poll_irq_timeout_hvm(int irq, u64 timeout)
 {
 	evtchn_port_t evtchn = evtchn_from_irq(irq);
 
@@ -1532,20 +1543,20 @@
 		poll.timeout = timeout;
 		set_xen_guest_handle(poll.ports, &evtchn);
 
-		if (HYPERVISOR_sched_op(SCHEDOP_poll, &poll) != 0)
+		if (HYPERVISOR_blanket_sched_op(SCHEDOP_poll, &poll) != 0)
 			BUG();
 	}
 }
-EXPORT_SYMBOL(xen_poll_irq_timeout);
+EXPORT_SYMBOL(xen_poll_irq_timeout_hvm);
 /* Poll waiting for an irq to become pending.  In the usual case, the
  * irq will be disabled so it won't deliver an interrupt. */
-void xen_poll_irq(int irq)
+void xen_poll_irq_hvm(int irq)
 {
-	xen_poll_irq_timeout(irq, 0 /* no timeout */);
+	xen_poll_irq_timeout_hvm(irq, 0 /* no timeout */);
 }
 
 /* Check whether the IRQ line is shared with other guests. */
-int xen_test_irq_shared(int irq)
+int xen_test_irq_shared_hvm(int irq)
 {
 	struct irq_info *info = info_for_irq(irq);
 	struct physdev_irq_status_query irq_status = { .irq = info->u.pirq.pirq };
@@ -1554,9 +1565,9 @@
 		return 0;
 	return !(irq_status.flags & XENIRQSTAT_shared);
 }
-EXPORT_SYMBOL_GPL(xen_test_irq_shared);
+EXPORT_SYMBOL_GPL(xen_test_irq_shared_hvm);
 
-void xen_irq_resume(void)
+void xen_irq_resume_hvm(void)
 {
 	unsigned int cpu, evtchn;
 	struct irq_info *info;
@@ -1583,7 +1594,7 @@
 }
 
 static struct irq_chip xen_dynamic_chip __read_mostly = {
-	.name			= "xen-dyn",
+	.name			= "xen-dyn-hvm",
 
 	.irq_disable		= disable_dynirq,
 	.irq_mask		= disable_dynirq,
@@ -1597,7 +1608,7 @@
 };
 
 static struct irq_chip xen_pirq_chip __read_mostly = {
-	.name			= "xen-pirq",
+	.name			= "xen-pirq-hvm",
 
 	.irq_startup		= startup_pirq,
 	.irq_shutdown		= shutdown_pirq,
@@ -1617,7 +1628,7 @@
 };
 
 static struct irq_chip xen_percpu_chip __read_mostly = {
-	.name			= "xen-percpu",
+	.name			= "xen-percpu-hvm",
 
 	.irq_disable		= disable_dynirq,
 	.irq_mask		= disable_dynirq,
@@ -1626,31 +1637,31 @@
 	.irq_ack		= ack_dynirq,
 };
 
-int xen_set_callback_via(uint64_t via)
+int xen_set_callback_via_hvm(uint64_t via)
 {
 	struct xen_hvm_param a;
 	a.domid = DOMID_SELF;
 	a.index = HVM_PARAM_CALLBACK_IRQ;
 	a.value = via;
-	return HYPERVISOR_hvm_op(HVMOP_set_param, &a);
+	return HYPERVISOR_blanket_hvm_op(HVMOP_set_param, &a);
 }
-EXPORT_SYMBOL_GPL(xen_set_callback_via);
+EXPORT_SYMBOL_GPL(xen_set_callback_via_hvm);
 
 #ifdef CONFIG_XEN_PVHVM
 /* Vector callbacks are better than PCI interrupts to receive event
  * channel notifications because we can receive vector callbacks on any
  * vcpu and we don't need PCI support or APIC interactions. */
-void xen_callback_vector(void)
+void xen_callback_vector_hvm(void)
 {
 	int rc;
 	uint64_t callback_via;
-	if (xen_have_vector_callback) {
+	if (xen_have_vector_callback_hvm) {
 		callback_via = HVM_CALLBACK_VECTOR(XEN_HVM_EVTCHN_CALLBACK);
-		rc = xen_set_callback_via(callback_via);
+		rc = xen_set_callback_via_hvm(callback_via);
 		if (rc) {
 			printk(KERN_ERR "Request for Xen HVM callback vector"
 					" failed.\n");
-			xen_have_vector_callback = 0;
+			xen_have_vector_callback_hvm = 0;
 			return;
 		}
 		printk(KERN_INFO "Xen HVM callback vector for event delivery is "
@@ -1661,10 +1672,10 @@
 	}
 }
 #else
-void xen_callback_vector(void) {}
+void xen_callback_vector_hvm(void) {}
 #endif
 
-void __init xen_init_IRQ(void)
+void __init xen_init_IRQ_hvm(void)
 {
 	int i;
 
@@ -1679,15 +1690,8 @@
 	for (i = 0; i < NR_EVENT_CHANNELS; i++)
 		mask_evtchn(i);
 
-	if (xen_hvm_domain()) {
-		xen_callback_vector();
-		native_init_IRQ();
-		/* pci_xen_hvm_init must be called after native_init_IRQ so that
-		 * __acpi_register_gsi can point at the right function */
-		pci_xen_hvm_init();
-	} else {
-		irq_ctx_init(smp_processor_id());
-		if (xen_initial_domain())
-			pci_xen_initial_domain();
+	if (xenblanket_platform) {
+		xen_callback_vector_hvm();
 	}
+	xenblanket_irq_initialized = 1;
 }
diff -Nur linux-3.1.2/drivers/xen-blanket/events.h linux-3.1.2-xenblanket/drivers/xen-blanket/events.h
--- linux-3.1.2/drivers/xen-blanket/events.h	2012-04-09 05:27:46.614422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/events.h	2012-03-02 20:28:43.000000000 -0500
@@ -1,5 +1,5 @@
-#ifndef _XEN_EVENTS_H
-#define _XEN_EVENTS_H
+#ifndef _XENBLANKET_EVENTS_H
+#define _XENBLANKET_EVENTS_H
 
 #include <linux/interrupt.h>
 
@@ -7,23 +7,26 @@
 #include <asm/xen/hypercall.h>
 #include <asm/xen/events.h>
 
-int bind_evtchn_to_irq(unsigned int evtchn);
-int bind_evtchn_to_irqhandler(unsigned int evtchn,
+#include "xenblanket.h"
+#include "xenblanket_hypercall.h"
+
+int bind_evtchn_to_irq_hvm(unsigned int evtchn);
+int bind_evtchn_to_irqhandler_hvm(unsigned int evtchn,
 			      irq_handler_t handler,
 			      unsigned long irqflags, const char *devname,
 			      void *dev_id);
-int bind_virq_to_irq(unsigned int virq, unsigned int cpu);
-int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
+int bind_virq_to_irq_hvm(unsigned int virq, unsigned int cpu);
+int bind_virq_to_irqhandler_hvm(unsigned int virq, unsigned int cpu,
 			    irq_handler_t handler,
 			    unsigned long irqflags, const char *devname,
 			    void *dev_id);
-int bind_ipi_to_irqhandler(enum ipi_vector ipi,
+int bind_ipi_to_irqhandler_hvm(enum ipi_vector ipi,
 			   unsigned int cpu,
 			   irq_handler_t handler,
 			   unsigned long irqflags,
 			   const char *devname,
 			   void *dev_id);
-int bind_interdomain_evtchn_to_irqhandler(unsigned int remote_domain,
+int bind_interdomain_evtchn_to_irqhandler_hvm(unsigned int remote_domain,
 					  unsigned int remote_port,
 					  irq_handler_t handler,
 					  unsigned long irqflags,
@@ -35,68 +38,71 @@
  * Automatically closes the underlying event channel (even for bindings
  * made with bind_evtchn_to_irqhandler()).
  */
-void unbind_from_irqhandler(unsigned int irq, void *dev_id);
+void unbind_from_irqhandler_hvm(unsigned int irq, void *dev_id);
 
-void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector);
-int resend_irq_on_evtchn(unsigned int irq);
-void rebind_evtchn_irq(int evtchn, int irq);
+void xen_send_IPI_one_hvm(unsigned int cpu, enum ipi_vector vector);
+int resend_irq_on_evtchn_hvm(unsigned int irq);
+void rebind_evtchn_irq_hvm(int evtchn, int irq);
 
-static inline void notify_remote_via_evtchn(int port)
+static inline void notify_remote_via_evtchn_hvm(int port)
 {
 	struct evtchn_send send = { .port = port };
-	(void)HYPERVISOR_event_channel_op(EVTCHNOP_send, &send);
+	(void)HYPERVISOR_blanket_event_channel_op(EVTCHNOP_send, &send);
 }
 
-void notify_remote_via_irq(int irq);
+void notify_remote_via_irq_hvm(int irq);
 
-void xen_irq_resume(void);
+void xen_irq_resume_hvm(void);
 
 /* Clear an irq's pending state, in preparation for polling on it */
-void xen_clear_irq_pending(int irq);
-void xen_set_irq_pending(int irq);
-bool xen_test_irq_pending(int irq);
+void xen_clear_irq_pending_hvm(int irq);
+void xen_set_irq_pending_hvm(int irq);
+bool xen_test_irq_pending_hvm(int irq);
 
 /* Poll waiting for an irq to become pending.  In the usual case, the
    irq will be disabled so it won't deliver an interrupt. */
-void xen_poll_irq(int irq);
+void xen_poll_irq_hvm(int irq);
 
 /* Poll waiting for an irq to become pending with a timeout.  In the usual case,
  * the irq will be disabled so it won't deliver an interrupt. */
-void xen_poll_irq_timeout(int irq, u64 timeout);
+void xen_poll_irq_timeout_hvm(int irq, u64 timeout);
 
 /* Determine the IRQ which is bound to an event channel */
-unsigned irq_from_evtchn(unsigned int evtchn);
+unsigned irq_from_evtchn_hvm(unsigned int evtchn);
 
 /* Xen HVM evtchn vector callback */
 void xen_hvm_callback_vector(void);
-extern int xen_have_vector_callback;
-int xen_set_callback_via(uint64_t via);
-void xen_evtchn_do_upcall(struct pt_regs *regs);
-void xen_hvm_evtchn_do_upcall(void);
+extern int xen_have_vector_callback_hvm;
+int xen_set_callback_via_hvm(uint64_t via);
+void xen_evtchn_do_upcall_hvm(struct pt_regs *regs);
+void xen_hvm_evtchn_do_upcall_hvm(void);
 
 /* Bind a pirq for a physical interrupt to an irq. */
-int xen_bind_pirq_gsi_to_irq(unsigned gsi,
+int xen_bind_pirq_gsi_to_irq_hvm(unsigned gsi,
 			     unsigned pirq, int shareable, char *name);
 
 #ifdef CONFIG_PCI_MSI
 /* Allocate a pirq for a MSI style physical interrupt. */
-int xen_allocate_pirq_msi(struct pci_dev *dev, struct msi_desc *msidesc);
+int xen_allocate_pirq_msi_hvm(struct pci_dev *dev, struct msi_desc *msidesc);
 /* Bind an PSI pirq to an irq. */
-int xen_bind_pirq_msi_to_irq(struct pci_dev *dev, struct msi_desc *msidesc,
+int xen_bind_pirq_msi_to_irq_hvm(struct pci_dev *dev, struct msi_desc *msidesc,
 			     int pirq, int vector, const char *name,
 			     domid_t domid);
 #endif
 
 /* De-allocates the above mentioned physical interrupt. */
-int xen_destroy_irq(int irq);
+int xen_destroy_irq_hvm(int irq);
 
 /* Return irq from pirq */
-int xen_irq_from_pirq(unsigned pirq);
+int xen_irq_from_pirq_hvm(unsigned pirq);
 
 /* Return the pirq allocated to the irq. */
-int xen_pirq_from_irq(unsigned irq);
+int xen_pirq_from_irq_hvm(unsigned irq);
 
 /* Determine whether to ignore this IRQ if it is passed to a guest. */
-int xen_test_irq_shared(int irq);
+int xen_test_irq_shared_hvm(int irq);
+
+/* Initialize */
+void __init xen_init_IRQ_hvm(void);
 
 #endif	/* _XEN_EVENTS_H */
diff -Nur linux-3.1.2/drivers/xen-blanket/features.c linux-3.1.2-xenblanket/drivers/xen-blanket/features.c
--- linux-3.1.2/drivers/xen-blanket/features.c	2012-04-09 05:27:46.601422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/features.c	2012-03-02 20:28:43.000000000 -0500
@@ -13,21 +13,23 @@
 
 #include <xen/interface/xen.h>
 #include <xen/interface/version.h>
-#include <xen/features.h>
+#include "features.h"
+#include "xenblanket.h"
+#include "xenblanket_hypercall.h"
 
-u8 xen_features[XENFEAT_NR_SUBMAPS * 32] __read_mostly;
-EXPORT_SYMBOL_GPL(xen_features);
+u8 xen_features_hvm[XENFEAT_NR_SUBMAPS * 32] __read_mostly;
+EXPORT_SYMBOL_GPL(xen_features_hvm);
 
-void xen_setup_features(void)
+void xen_setup_features_hvm(void)
 {
 	struct xen_feature_info fi;
 	int i, j;
 
 	for (i = 0; i < XENFEAT_NR_SUBMAPS; i++) {
 		fi.submap_idx = i;
-		if (HYPERVISOR_xen_version(XENVER_get_features, &fi) < 0)
+		if (HYPERVISOR_blanket_xen_version(XENVER_get_features, &fi) < 0)
 			break;
 		for (j = 0; j < 32; j++)
-			xen_features[i * 32 + j] = !!(fi.submap & 1<<j);
+			xen_features_hvm[i * 32 + j] = !!(fi.submap & 1<<j);
 	}
 }
diff -Nur linux-3.1.2/drivers/xen-blanket/features.h linux-3.1.2-xenblanket/drivers/xen-blanket/features.h
--- linux-3.1.2/drivers/xen-blanket/features.h	2012-04-09 05:27:46.614422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/features.h	2012-03-02 20:28:43.000000000 -0500
@@ -6,18 +6,18 @@
  * Copyright (c) 2006, Ian Campbell
  */
 
-#ifndef __XEN_FEATURES_H__
-#define __XEN_FEATURES_H__
+#ifndef __XENBLANKET_FEATURES_H__
+#define __XENBLANKET_FEATURES_H__
 
 #include <xen/interface/features.h>
 
-void xen_setup_features(void);
+void xen_setup_features_hvm(void);
 
-extern u8 xen_features[XENFEAT_NR_SUBMAPS * 32];
+extern u8 xen_features_hvm[XENFEAT_NR_SUBMAPS * 32];
 
-static inline int xen_feature(int flag)
+static inline int xen_feature_hvm(int flag)
 {
-	return xen_features[flag];
+	return xen_features_hvm[flag];
 }
 
 #endif /* __ASM_XEN_FEATURES_H__ */
diff -Nur linux-3.1.2/drivers/xen-blanket/grant-table.c linux-3.1.2-xenblanket/drivers/xen-blanket/grant-table.c
--- linux-3.1.2/drivers/xen-blanket/grant-table.c	2012-04-09 05:27:46.603422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/grant-table.c	2012-04-09 06:31:42.352422002 -0400
@@ -42,13 +42,15 @@
 #include <xen/xen.h>
 #include <xen/interface/xen.h>
 #include <xen/page.h>
-#include <xen/grant_table.h>
+#include "grant_table.h"
 #include <xen/interface/memory.h>
 #include <asm/xen/hypercall.h>
 
 #include <asm/pgtable.h>
 #include <asm/sync_bitops.h>
 
+#include "xenblanket.h"
+#include "xenblanket_hypercall.h"
 
 /* External tools reserve first few grant table entries. */
 #define NR_RESERVED_ENTRIES 8
@@ -61,8 +63,8 @@
 static int gnttab_free_count;
 static grant_ref_t gnttab_free_head;
 static DEFINE_SPINLOCK(gnttab_list_lock);
-unsigned long xen_hvm_resume_frames;
-EXPORT_SYMBOL_GPL(xen_hvm_resume_frames);
+unsigned long xen_hvm_resume_frames_hvm;
+EXPORT_SYMBOL_GPL(xen_hvm_resume_frames_hvm);
 
 static struct grant_entry *shared;
 
@@ -164,15 +166,15 @@
 /*
  * Public grant-issuing interface functions
  */
-void gnttab_grant_foreign_access_ref(grant_ref_t ref, domid_t domid,
+void gnttab_grant_foreign_access_ref_hvm(grant_ref_t ref, domid_t domid,
 				     unsigned long frame, int readonly)
 {
 	update_grant_entry(ref, domid, frame,
 			   GTF_permit_access | (readonly ? GTF_readonly : 0));
 }
-EXPORT_SYMBOL_GPL(gnttab_grant_foreign_access_ref);
+EXPORT_SYMBOL_GPL(gnttab_grant_foreign_access_ref_hvm);
 
-int gnttab_grant_foreign_access(domid_t domid, unsigned long frame,
+int gnttab_grant_foreign_access_hvm(domid_t domid, unsigned long frame,
 				int readonly)
 {
 	int ref;
@@ -181,13 +183,13 @@
 	if (unlikely(ref < 0))
 		return -ENOSPC;
 
-	gnttab_grant_foreign_access_ref(ref, domid, frame, readonly);
+	gnttab_grant_foreign_access_ref_hvm(ref, domid, frame, readonly);
 
 	return ref;
 }
-EXPORT_SYMBOL_GPL(gnttab_grant_foreign_access);
+EXPORT_SYMBOL_GPL(gnttab_grant_foreign_access_hvm);
 
-int gnttab_query_foreign_access(grant_ref_t ref)
+int gnttab_query_foreign_access_hvm(grant_ref_t ref)
 {
 	u16 nflags;
 
@@ -195,9 +197,9 @@
 
 	return (nflags & (GTF_reading|GTF_writing));
 }
-EXPORT_SYMBOL_GPL(gnttab_query_foreign_access);
+EXPORT_SYMBOL_GPL(gnttab_query_foreign_access_hvm);
 
-int gnttab_end_foreign_access_ref(grant_ref_t ref, int readonly)
+int gnttab_end_foreign_access_ref_hvm(grant_ref_t ref, int readonly)
 {
 	u16 flags, nflags;
 
@@ -212,12 +214,12 @@
 
 	return 1;
 }
-EXPORT_SYMBOL_GPL(gnttab_end_foreign_access_ref);
+EXPORT_SYMBOL_GPL(gnttab_end_foreign_access_ref_hvm);
 
-void gnttab_end_foreign_access(grant_ref_t ref, int readonly,
+void gnttab_end_foreign_access_hvm(grant_ref_t ref, int readonly,
 			       unsigned long page)
 {
-	if (gnttab_end_foreign_access_ref(ref, readonly)) {
+	if (gnttab_end_foreign_access_ref_hvm(ref, readonly)) {
 		put_free_entry(ref);
 		if (page != 0)
 			free_page(page);
@@ -228,29 +230,29 @@
 		       "WARNING: leaking g.e. and page still in use!\n");
 	}
 }
-EXPORT_SYMBOL_GPL(gnttab_end_foreign_access);
+EXPORT_SYMBOL_GPL(gnttab_end_foreign_access_hvm);
 
-int gnttab_grant_foreign_transfer(domid_t domid, unsigned long pfn)
+int gnttab_grant_foreign_transfer_hvm(domid_t domid, unsigned long pfn)
 {
 	int ref;
 
 	ref = get_free_entries(1);
 	if (unlikely(ref < 0))
 		return -ENOSPC;
-	gnttab_grant_foreign_transfer_ref(ref, domid, pfn);
+	gnttab_grant_foreign_transfer_ref_hvm(ref, domid, pfn);
 
 	return ref;
 }
-EXPORT_SYMBOL_GPL(gnttab_grant_foreign_transfer);
+EXPORT_SYMBOL_GPL(gnttab_grant_foreign_transfer_hvm);
 
-void gnttab_grant_foreign_transfer_ref(grant_ref_t ref, domid_t domid,
+void gnttab_grant_foreign_transfer_ref_hvm(grant_ref_t ref, domid_t domid,
 				       unsigned long pfn)
 {
 	update_grant_entry(ref, domid, pfn, GTF_accept_transfer);
 }
-EXPORT_SYMBOL_GPL(gnttab_grant_foreign_transfer_ref);
+EXPORT_SYMBOL_GPL(gnttab_grant_foreign_transfer_ref_hvm);
 
-unsigned long gnttab_end_foreign_transfer_ref(grant_ref_t ref)
+unsigned long gnttab_end_foreign_transfer_ref_hvm(grant_ref_t ref)
 {
 	unsigned long frame;
 	u16           flags;
@@ -277,23 +279,23 @@
 
 	return frame;
 }
-EXPORT_SYMBOL_GPL(gnttab_end_foreign_transfer_ref);
+EXPORT_SYMBOL_GPL(gnttab_end_foreign_transfer_ref_hvm);
 
-unsigned long gnttab_end_foreign_transfer(grant_ref_t ref)
+unsigned long gnttab_end_foreign_transfer_hvm(grant_ref_t ref)
 {
-	unsigned long frame = gnttab_end_foreign_transfer_ref(ref);
+	unsigned long frame = gnttab_end_foreign_transfer_ref_hvm(ref);
 	put_free_entry(ref);
 	return frame;
 }
-EXPORT_SYMBOL_GPL(gnttab_end_foreign_transfer);
+EXPORT_SYMBOL_GPL(gnttab_end_foreign_transfer_hvm);
 
-void gnttab_free_grant_reference(grant_ref_t ref)
+void gnttab_free_grant_reference_hvm(grant_ref_t ref)
 {
 	put_free_entry(ref);
 }
-EXPORT_SYMBOL_GPL(gnttab_free_grant_reference);
+EXPORT_SYMBOL_GPL(gnttab_free_grant_reference_hvm);
 
-void gnttab_free_grant_references(grant_ref_t head)
+void gnttab_free_grant_references_hvm(grant_ref_t head)
 {
 	grant_ref_t ref;
 	unsigned long flags;
@@ -312,9 +314,9 @@
 	check_free_callbacks();
 	spin_unlock_irqrestore(&gnttab_list_lock, flags);
 }
-EXPORT_SYMBOL_GPL(gnttab_free_grant_references);
+EXPORT_SYMBOL_GPL(gnttab_free_grant_references_hvm);
 
-int gnttab_alloc_grant_references(u16 count, grant_ref_t *head)
+int gnttab_alloc_grant_references_hvm(u16 count, grant_ref_t *head)
 {
 	int h = get_free_entries(count);
 
@@ -325,15 +327,15 @@
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(gnttab_alloc_grant_references);
+EXPORT_SYMBOL_GPL(gnttab_alloc_grant_references_hvm);
 
-int gnttab_empty_grant_references(const grant_ref_t *private_head)
+int gnttab_empty_grant_references_hvm(const grant_ref_t *private_head)
 {
 	return (*private_head == GNTTAB_LIST_END);
 }
-EXPORT_SYMBOL_GPL(gnttab_empty_grant_references);
+EXPORT_SYMBOL_GPL(gnttab_empty_grant_references_hvm);
 
-int gnttab_claim_grant_reference(grant_ref_t *private_head)
+int gnttab_claim_grant_reference_hvm(grant_ref_t *private_head)
 {
 	grant_ref_t g = *private_head;
 	if (unlikely(g == GNTTAB_LIST_END))
@@ -341,17 +343,17 @@
 	*private_head = gnttab_entry(g);
 	return g;
 }
-EXPORT_SYMBOL_GPL(gnttab_claim_grant_reference);
+EXPORT_SYMBOL_GPL(gnttab_claim_grant_reference_hvm);
 
-void gnttab_release_grant_reference(grant_ref_t *private_head,
+void gnttab_release_grant_reference_hvm(grant_ref_t *private_head,
 				    grant_ref_t release)
 {
 	gnttab_entry(release) = *private_head;
 	*private_head = release;
 }
-EXPORT_SYMBOL_GPL(gnttab_release_grant_reference);
+EXPORT_SYMBOL_GPL(gnttab_release_grant_reference_hvm);
 
-void gnttab_request_free_callback(struct gnttab_free_callback *callback,
+void gnttab_request_free_callback_hvm(struct gnttab_free_callback *callback,
 				  void (*fn)(void *), void *arg, u16 count)
 {
 	unsigned long flags;
@@ -367,9 +369,9 @@
 out:
 	spin_unlock_irqrestore(&gnttab_list_lock, flags);
 }
-EXPORT_SYMBOL_GPL(gnttab_request_free_callback);
+EXPORT_SYMBOL_GPL(gnttab_request_free_callback_hvm);
 
-void gnttab_cancel_free_callback(struct gnttab_free_callback *callback)
+void gnttab_cancel_free_callback_hvm(struct gnttab_free_callback *callback)
 {
 	struct gnttab_free_callback **pcb;
 	unsigned long flags;
@@ -383,7 +385,7 @@
 	}
 	spin_unlock_irqrestore(&gnttab_list_lock, flags);
 }
-EXPORT_SYMBOL_GPL(gnttab_cancel_free_callback);
+EXPORT_SYMBOL_GPL(gnttab_cancel_free_callback_hvm);
 
 static int grow_gnttab_list(unsigned int more_frames)
 {
@@ -430,14 +432,14 @@
 
 	query.dom = DOMID_SELF;
 
-	rc = HYPERVISOR_grant_table_op(GNTTABOP_query_size, &query, 1);
+	rc = HYPERVISOR_blanket_grant_table_op(GNTTABOP_query_size, &query, 1);
 	if ((rc < 0) || (query.status != GNTST_okay))
 		return 4; /* Legacy max supported number of frames */
 
 	return query.max_nr_frames;
 }
 
-unsigned int gnttab_max_grant_frames(void)
+unsigned int gnttab_max_grant_frames_hvm(void)
 {
 	unsigned int xen_max = __max_nr_grant_frames();
 
@@ -445,9 +447,9 @@
 		return boot_max_nr_grant_frames;
 	return xen_max;
 }
-EXPORT_SYMBOL_GPL(gnttab_max_grant_frames);
+EXPORT_SYMBOL_GPL(gnttab_max_grant_frames_hvm);
 
-int gnttab_map_refs(struct gnttab_map_grant_ref *map_ops,
+int gnttab_map_refs_hvm(struct gnttab_map_grant_ref *map_ops,
 		    struct page **pages, unsigned int count)
 {
 	int i, ret;
@@ -496,9 +498,9 @@
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(gnttab_map_refs);
+EXPORT_SYMBOL_GPL(gnttab_map_refs_hvm);
 
-int gnttab_unmap_refs(struct gnttab_unmap_grant_ref *unmap_ops,
+int gnttab_unmap_refs_hvm(struct gnttab_unmap_grant_ref *unmap_ops,
 		struct page **pages, unsigned int count)
 {
 	int i, ret;
@@ -518,7 +520,7 @@
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(gnttab_unmap_refs);
+EXPORT_SYMBOL_GPL(gnttab_unmap_refs_hvm);
 
 static int gnttab_map(unsigned int start_idx, unsigned int end_idx)
 {
@@ -527,7 +529,7 @@
 	unsigned int nr_gframes = end_idx + 1;
 	int rc;
 
-	if (xen_hvm_domain()) {
+	if (xenblanket_platform) {
 		struct xen_add_to_physmap xatp;
 		unsigned int i = end_idx;
 		rc = 0;
@@ -539,8 +541,8 @@
 			xatp.domid = DOMID_SELF;
 			xatp.idx = i;
 			xatp.space = XENMAPSPACE_grant_table;
-			xatp.gpfn = (xen_hvm_resume_frames >> PAGE_SHIFT) + i;
-			rc = HYPERVISOR_memory_op(XENMEM_add_to_physmap, &xatp);
+			xatp.gpfn = (xen_hvm_resume_frames_hvm >> PAGE_SHIFT) + i;
+			rc = HYPERVISOR_blanket_memory_op(XENMEM_add_to_physmap, &xatp);
 			if (rc != 0) {
 				printk(KERN_WARNING
 						"grant table add_to_physmap failed, err=%d\n", rc);
@@ -567,7 +569,7 @@
 
 	BUG_ON(rc || setup.status);
 
-	rc = arch_gnttab_map_shared(frames, nr_gframes, gnttab_max_grant_frames(),
+	rc = arch_gnttab_map_shared(frames, nr_gframes, gnttab_max_grant_frames_hvm(),
 				    &shared);
 	BUG_ON(rc);
 
@@ -576,19 +578,20 @@
 	return 0;
 }
 
-int gnttab_resume(void)
+int gnttab_resume_hvm(void)
 {
 	unsigned int max_nr_gframes;
 
-	max_nr_gframes = gnttab_max_grant_frames();
+	max_nr_gframes = gnttab_max_grant_frames_hvm();
 	if (max_nr_gframes < nr_grant_frames)
 		return -ENOSYS;
 
-	if (xen_pv_domain())
-		return gnttab_map(0, nr_grant_frames - 1);
+	if(!xenblanket_platform) {
+		return -1;
+	}
 
 	if (!shared) {
-		shared = ioremap(xen_hvm_resume_frames, PAGE_SIZE * max_nr_gframes);
+		shared = ioremap(xen_hvm_resume_frames_hvm, PAGE_SIZE * max_nr_gframes);
 		if (shared == NULL) {
 			printk(KERN_WARNING
 					"Failed to ioremap gnttab share frames!");
@@ -601,7 +604,7 @@
 	return 0;
 }
 
-int gnttab_suspend(void)
+int gnttab_suspend_hvm(void)
 {
 	arch_gnttab_unmap_shared(shared, nr_grant_frames);
 	return 0;
@@ -615,7 +618,7 @@
 	cur = nr_grant_frames;
 	extra = ((req_entries + (GREFS_PER_GRANT_FRAME-1)) /
 		 GREFS_PER_GRANT_FRAME);
-	if (cur + extra > gnttab_max_grant_frames())
+	if (cur + extra > gnttab_max_grant_frames_hvm())
 		return -ENOSPC;
 
 	rc = gnttab_map(cur, cur + extra - 1);
@@ -625,7 +628,7 @@
 	return rc;
 }
 
-int gnttab_init(void)
+int gnttab_init_hvm(void)
 {
 	int i;
 	unsigned int max_nr_glist_frames, nr_glist_frames;
@@ -652,7 +655,7 @@
 			goto ini_nomem;
 	}
 
-	if (gnttab_resume() < 0)
+	if (gnttab_resume_hvm() < 0)
 		return -ENODEV;
 
 	nr_init_grefs = nr_grant_frames * GREFS_PER_GRANT_FRAME;
@@ -673,7 +676,7 @@
 	kfree(gnttab_list);
 	return -ENOMEM;
 }
-EXPORT_SYMBOL_GPL(gnttab_init);
+EXPORT_SYMBOL_GPL(gnttab_init_hvm);
 
 static int __devinit __gnttab_init(void)
 {
@@ -684,7 +687,7 @@
 	if (!xen_pv_domain())
 		return -ENODEV;
 
-	return gnttab_init();
+	return gnttab_init_hvm();
 }
 
-core_initcall(__gnttab_init);
+//core_initcall(__gnttab_init);
diff -Nur linux-3.1.2/drivers/xen-blanket/grant_table.h linux-3.1.2-xenblanket/drivers/xen-blanket/grant_table.h
--- linux-3.1.2/drivers/xen-blanket/grant_table.h	2012-04-09 05:27:46.615422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/grant_table.h	2012-03-02 20:28:44.000000000 -0500
@@ -34,8 +34,8 @@
  * IN THE SOFTWARE.
  */
 
-#ifndef __ASM_GNTTAB_H__
-#define __ASM_GNTTAB_H__
+#ifndef __ASM_XENBLANKET_GNTTAB_H__
+#define __ASM_XENBLANKET_GNTTAB_H__
 
 #include <asm/page.h>
 
@@ -45,7 +45,7 @@
 #include <asm/xen/hypervisor.h>
 #include <asm/xen/grant_table.h>
 
-#include <xen/features.h>
+#include "features.h"
 
 /* NR_GRANT_FRAMES must be less than or equal to that configured in Xen */
 #define NR_GRANT_FRAMES 4
@@ -57,11 +57,11 @@
 	u16 count;
 };
 
-int gnttab_init(void);
-int gnttab_suspend(void);
-int gnttab_resume(void);
+int gnttab_init_hvm(void);
+int gnttab_suspend_hvm(void);
+int gnttab_resume_hvm(void);
 
-int gnttab_grant_foreign_access(domid_t domid, unsigned long frame,
+int gnttab_grant_foreign_access_hvm(domid_t domid, unsigned long frame,
 				int readonly);
 
 /*
@@ -69,7 +69,7 @@
  * longer in use.  Return 1 if the grant entry was freed, 0 if it is still in
  * use.
  */
-int gnttab_end_foreign_access_ref(grant_ref_t ref, int readonly);
+int gnttab_end_foreign_access_ref_hvm(grant_ref_t ref, int readonly);
 
 /*
  * Eventually end access through the given grant reference, and once that
@@ -77,40 +77,40 @@
  * immediately iff the grant entry is not in use, otherwise it will happen
  * some time later.  page may be 0, in which case no freeing will occur.
  */
-void gnttab_end_foreign_access(grant_ref_t ref, int readonly,
+void gnttab_end_foreign_access_hvm(grant_ref_t ref, int readonly,
 			       unsigned long page);
 
 int gnttab_grant_foreign_transfer(domid_t domid, unsigned long pfn);
 
-unsigned long gnttab_end_foreign_transfer_ref(grant_ref_t ref);
-unsigned long gnttab_end_foreign_transfer(grant_ref_t ref);
+unsigned long gnttab_end_foreign_transfer_ref_hvm(grant_ref_t ref);
+unsigned long gnttab_end_foreign_transfer_hvm(grant_ref_t ref);
 
-int gnttab_query_foreign_access(grant_ref_t ref);
+int gnttab_query_foreign_access_hvm(grant_ref_t ref);
 
 /*
  * operations on reserved batches of grant references
  */
-int gnttab_alloc_grant_references(u16 count, grant_ref_t *pprivate_head);
+int gnttab_alloc_grant_references_hvm(u16 count, grant_ref_t *pprivate_head);
 
-void gnttab_free_grant_reference(grant_ref_t ref);
+void gnttab_free_grant_reference_hvm(grant_ref_t ref);
 
-void gnttab_free_grant_references(grant_ref_t head);
+void gnttab_free_grant_references_hvm(grant_ref_t head);
 
-int gnttab_empty_grant_references(const grant_ref_t *pprivate_head);
+int gnttab_empty_grant_references_hvm(const grant_ref_t *pprivate_head);
 
-int gnttab_claim_grant_reference(grant_ref_t *pprivate_head);
+int gnttab_claim_grant_reference_hvm(grant_ref_t *pprivate_head);
 
-void gnttab_release_grant_reference(grant_ref_t *private_head,
+void gnttab_release_grant_reference_hvm(grant_ref_t *private_head,
 				    grant_ref_t release);
 
-void gnttab_request_free_callback(struct gnttab_free_callback *callback,
+void gnttab_request_free_callback_hvm(struct gnttab_free_callback *callback,
 				  void (*fn)(void *), void *arg, u16 count);
-void gnttab_cancel_free_callback(struct gnttab_free_callback *callback);
+void gnttab_cancel_free_callback_hvm(struct gnttab_free_callback *callback);
 
-void gnttab_grant_foreign_access_ref(grant_ref_t ref, domid_t domid,
+void gnttab_grant_foreign_access_ref_hvm(grant_ref_t ref, domid_t domid,
 				     unsigned long frame, int readonly);
 
-void gnttab_grant_foreign_transfer_ref(grant_ref_t, domid_t domid,
+void gnttab_grant_foreign_transfer_ref_hvm(grant_ref_t, domid_t domid,
 				       unsigned long pfn);
 
 static inline void
@@ -119,7 +119,7 @@
 {
 	if (flags & GNTMAP_contains_pte)
 		map->host_addr = addr;
-	else if (xen_feature(XENFEAT_auto_translated_physmap))
+	else if (xen_feature_hvm(XENFEAT_auto_translated_physmap))
 		map->host_addr = __pa(addr);
 	else
 		map->host_addr = addr;
@@ -135,7 +135,7 @@
 {
 	if (flags & GNTMAP_contains_pte)
 		unmap->host_addr = addr;
-	else if (xen_feature(XENFEAT_auto_translated_physmap))
+	else if (xen_feature_hvm(XENFEAT_auto_translated_physmap))
 		unmap->host_addr = __pa(addr);
 	else
 		unmap->host_addr = addr;
@@ -150,14 +150,14 @@
 void arch_gnttab_unmap_shared(struct grant_entry *shared,
 			      unsigned long nr_gframes);
 
-extern unsigned long xen_hvm_resume_frames;
-unsigned int gnttab_max_grant_frames(void);
+extern unsigned long xen_hvm_resume_frames_hvm;
+unsigned int gnttab_max_grant_frames_hvm(void);
 
 #define gnttab_map_vaddr(map) ((void *)(map.host_virt_addr))
 
-int gnttab_map_refs(struct gnttab_map_grant_ref *map_ops,
+int gnttab_map_refs_hvm(struct gnttab_map_grant_ref *map_ops,
 		    struct page **pages, unsigned int count);
-int gnttab_unmap_refs(struct gnttab_unmap_grant_ref *unmap_ops,
+int gnttab_unmap_refs_hvm(struct gnttab_unmap_grant_ref *unmap_ops,
 		      struct page **pages, unsigned int count);
 
 #endif /* __ASM_GNTTAB_H__ */
diff -Nur linux-3.1.2/drivers/xen-blanket/manage.c linux-3.1.2-xenblanket/drivers/xen-blanket/manage.c
--- linux-3.1.2/drivers/xen-blanket/manage.c	2012-04-09 05:27:46.603422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/manage.c	2012-04-09 06:32:07.635422002 -0400
@@ -11,11 +11,11 @@
 #include <linux/syscore_ops.h>
 
 #include <xen/xen.h>
-#include <xen/xenbus.h>
-#include <xen/grant_table.h>
-#include <xen/events.h>
+#include "xenbus/xenbus.h"
+#include "grant_table.h"
+#include "events.h"
 #include <xen/hvc-console.h>
-#include <xen/xen-ops.h>
+#include "xen-ops.h"
 
 #include <asm/xen/hypercall.h>
 #include <asm/xen/page.h>
@@ -45,20 +45,20 @@
 static void xen_hvm_post_suspend(int cancelled)
 {
 	xen_arch_hvm_post_suspend(cancelled);
-	gnttab_resume();
+	gnttab_resume_hvm();
 }
 
 static void xen_pre_suspend(void)
 {
 	xen_mm_pin_all();
-	gnttab_suspend();
+	gnttab_suspend_hvm();
 	xen_arch_pre_suspend();
 }
 
 static void xen_post_suspend(int cancelled)
 {
 	xen_arch_post_suspend(cancelled);
-	gnttab_resume();
+	gnttab_resume_hvm();
 	xen_mm_unpin_all();
 }
 
@@ -91,7 +91,7 @@
 		si->post(si->cancelled);
 
 	if (!si->cancelled) {
-		xen_irq_resume();
+		xen_irq_resume_hvm();
 		xen_console_resume();
 		xen_timer_resume();
 	}
@@ -126,7 +126,7 @@
 	}
 
 	printk(KERN_DEBUG "suspending xenstore...\n");
-	xs_suspend();
+	xs_suspend_hvm();
 
 	err = dpm_suspend_noirq(PMSG_FREEZE);
 	if (err) {
@@ -158,9 +158,9 @@
 out_resume:
 	if (!si.cancelled) {
 		xen_arch_resume();
-		xs_resume();
+		xs_resume_hvm();
 	} else
-		xs_suspend_cancel();
+		xs_suspend_cancel_hvm();
 
 	dpm_resume_end(si.cancelled ? PMSG_THAW : PMSG_RESTORE);
 
@@ -214,14 +214,14 @@
 		return;
 
  again:
-	err = xenbus_transaction_start(&xbt);
+	err = xenbus_transaction_start_hvm(&xbt);
 	if (err)
 		return;
 
-	str = (char *)xenbus_read(xbt, "control", "shutdown", NULL);
+	str = (char *)xenbus_read_hvm(xbt, "control", "shutdown", NULL);
 	/* Ignore read errors and empty reads. */
 	if (XENBUS_IS_ERR_READ(str)) {
-		xenbus_transaction_end(xbt, 1);
+		xenbus_transaction_end_hvm(xbt, 1);
 		return;
 	}
 
@@ -232,9 +232,9 @@
 
 	/* Only acknowledge commands which we are prepared to handle. */
 	if (handler->cb)
-		xenbus_write(xbt, "control", "shutdown", "");
+		xenbus_write_hvm(xbt, "control", "shutdown", "");
 
-	err = xenbus_transaction_end(xbt, 0);
+	err = xenbus_transaction_end_hvm(xbt, 0);
 	if (err == -EAGAIN) {
 		kfree(str);
 		goto again;
@@ -259,20 +259,20 @@
 	int err;
 
  again:
-	err = xenbus_transaction_start(&xbt);
+	err = xenbus_transaction_start_hvm(&xbt);
 	if (err)
 		return;
-	if (!xenbus_scanf(xbt, "control", "sysrq", "%c", &sysrq_key)) {
+	if (!xenbus_scanf_hvm(xbt, "control", "sysrq", "%c", &sysrq_key)) {
 		printk(KERN_ERR "Unable to read sysrq code in "
 		       "control/sysrq\n");
-		xenbus_transaction_end(xbt, 1);
+		xenbus_transaction_end_hvm(xbt, 1);
 		return;
 	}
 
 	if (sysrq_key != '\0')
-		xenbus_printf(xbt, "control", "sysrq", "%c", '\0');
+		xenbus_printf_hvm(xbt, "control", "sysrq", "%c", '\0');
 
-	err = xenbus_transaction_end(xbt, 0);
+	err = xenbus_transaction_end_hvm(xbt, 0);
 	if (err == -EAGAIN)
 		goto again;
 
@@ -295,14 +295,14 @@
 {
 	int err;
 
-	err = register_xenbus_watch(&shutdown_watch);
+	err = register_xenbus_watch_hvm(&shutdown_watch);
 	if (err) {
 		printk(KERN_ERR "Failed to set shutdown watcher\n");
 		return err;
 	}
 
 #ifdef CONFIG_MAGIC_SYSRQ
-	err = register_xenbus_watch(&sysrq_watch);
+	err = register_xenbus_watch_hvm(&sysrq_watch);
 	if (err) {
 		printk(KERN_ERR "Failed to set sysrq watcher\n");
 		return err;
@@ -320,7 +320,7 @@
 	return NOTIFY_DONE;
 }
 
-int xen_setup_shutdown_event(void)
+int xen_setup_shutdown_event_hvm(void)
 {
 	static struct notifier_block xenstore_notifier = {
 		.notifier_call = shutdown_event
@@ -328,10 +328,10 @@
 
 	if (!xen_domain())
 		return -ENODEV;
-	register_xenstore_notifier(&xenstore_notifier);
+	register_xenstore_notifier_hvm(&xenstore_notifier);
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(xen_setup_shutdown_event);
+EXPORT_SYMBOL_GPL(xen_setup_shutdown_event_hvm);
 
-subsys_initcall(xen_setup_shutdown_event);
+//subsys_initcall(xen_setup_shutdown_event_hvm);
diff -Nur linux-3.1.2/drivers/xen-blanket/platform-pci-unplug.c linux-3.1.2-xenblanket/drivers/xen-blanket/platform-pci-unplug.c
--- linux-3.1.2/drivers/xen-blanket/platform-pci-unplug.c	2012-04-09 05:27:46.627422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/platform-pci-unplug.c	2012-03-02 20:28:44.000000000 -0500
@@ -29,10 +29,6 @@
 #define XEN_PLATFORM_ERR_PROTOCOL -2
 #define XEN_PLATFORM_ERR_BLACKLIST -3
 
-/* store the value of xen_emul_unplug after the unplug is done */
-int xen_platform_pci_unplug;
-EXPORT_SYMBOL_GPL(xen_platform_pci_unplug);
-#ifdef CONFIG_XEN_PVHVM
 static int xen_emul_unplug;
 
 static int check_platform_magic(void)
@@ -68,7 +64,7 @@
 	return 0;
 }
 
-void xen_unplug_emulated_devices(void)
+void xen_unplug_emulated_devices_hvm(void)
 {
 	int r;
 
@@ -88,19 +84,8 @@
 	 * not the Xen PV frontends and the Xen platform PCI driver have
 	 * been compiled for this kernel (modules or built-in are both OK). */
 	if (!xen_emul_unplug) {
-		if (xen_must_unplug_nics()) {
-			printk(KERN_INFO "Netfront and the Xen platform PCI driver have "
-					"been compiled for this kernel: unplug emulated NICs.\n");
-			xen_emul_unplug |= XEN_UNPLUG_ALL_NICS;
-		}
-		if (xen_must_unplug_disks()) {
-			printk(KERN_INFO "Blkfront and the Xen platform PCI driver have "
-					"been compiled for this kernel: unplug emulated disks.\n"
-					"You might have to change the root device\n"
-					"from /dev/hd[a-d] to /dev/xvd[a-d]\n"
-					"in your root= kernel command line option\n");
-			xen_emul_unplug |= XEN_UNPLUG_ALL_IDE_DISKS;
-		}
+		xen_emul_unplug |= XEN_UNPLUG_ALL_NICS;
+		xen_emul_unplug |= XEN_UNPLUG_ALL_IDE_DISKS;
 	}
 	/* Now unplug the emulated devices */
 	if (!(xen_emul_unplug & XEN_UNPLUG_UNNECESSARY))
@@ -108,36 +93,3 @@
 	xen_platform_pci_unplug = xen_emul_unplug;
 }
 
-static int __init parse_xen_emul_unplug(char *arg)
-{
-	char *p, *q;
-	int l;
-
-	for (p = arg; p; p = q) {
-		q = strchr(p, ',');
-		if (q) {
-			l = q - p;
-			q++;
-		} else {
-			l = strlen(p);
-		}
-		if (!strncmp(p, "all", l))
-			xen_emul_unplug |= XEN_UNPLUG_ALL;
-		else if (!strncmp(p, "ide-disks", l))
-			xen_emul_unplug |= XEN_UNPLUG_ALL_IDE_DISKS;
-		else if (!strncmp(p, "aux-ide-disks", l))
-			xen_emul_unplug |= XEN_UNPLUG_AUX_IDE_DISKS;
-		else if (!strncmp(p, "nics", l))
-			xen_emul_unplug |= XEN_UNPLUG_ALL_NICS;
-		else if (!strncmp(p, "unnecessary", l))
-			xen_emul_unplug |= XEN_UNPLUG_UNNECESSARY;
-		else if (!strncmp(p, "never", l))
-			xen_emul_unplug |= XEN_UNPLUG_NEVER;
-		else
-			printk(KERN_WARNING "unrecognised option '%s' "
-				 "in parameter 'xen_emul_unplug'\n", p);
-	}
-	return 0;
-}
-early_param("xen_emul_unplug", parse_xen_emul_unplug);
-#endif
diff -Nur linux-3.1.2/drivers/xen-blanket/platform-pci.c linux-3.1.2-xenblanket/drivers/xen-blanket/platform-pci.c
--- linux-3.1.2/drivers/xen-blanket/platform-pci.c	2012-04-09 05:27:46.603422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/platform-pci.c	2012-04-09 06:33:29.474422003 -0400
@@ -27,12 +27,20 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 
+#include <asm/xen/page.h>
+#include <linux/delay.h>
 #include <xen/platform_pci.h>
-#include <xen/grant_table.h>
-#include <xen/xenbus.h>
-#include <xen/events.h>
+#include "features.h"
+#include "grant_table.h"
+#include "xenbus/xenbus.h"
+#include "events.h"
+#include <xen/interface/memory.h>
 #include <xen/hvm.h>
 #include <xen/xen-ops.h>
+#include <asm/setup.h>
+#include <asm/xen/hypercall.h>
+#include "xenblanket.h"
+#include "xenblanket_hypercall.h"
 
 #define DRV_NAME    "xen-platform-pci"
 
@@ -40,12 +48,82 @@
 MODULE_DESCRIPTION("Xen platform PCI device");
 MODULE_LICENSE("GPL");
 
+int xen_setup_shutdown_event_hvm(void);
+void xen_unplug_emulated_devices_hvm(void);
+
 static unsigned long platform_mmio;
 static unsigned long platform_mmio_alloc;
 static unsigned long platform_mmiolen;
 static uint64_t callback_via;
 
-unsigned long alloc_xen_mmio(unsigned long len)
+static unsigned long alloc_xen_mmio_hvm(unsigned long len);
+
+static bool __init xen_blanket_platform(void)
+{
+        long rc = 0;
+        uint32_t base;
+        struct blanket_get_cpuid cpuid;
+        char signature[13] = {0};
+        printk("XENBLANKET-DOM0: detecting nested hvm environment.\n");
+        for (base = 0x40000000; base < 0x40010000; base += 100) {
+                rc = HYPERVISOR_blanket_get_cpuid(base, &cpuid);
+                if(rc)
+                        break;
+                *(uint32_t *)(signature + 0) = cpuid.ebx;
+                *(uint32_t *)(signature + 4) = cpuid.ecx;
+                *(uint32_t *)(signature + 8) = cpuid.edx;
+                signature[12] = 0;
+                if (!strcmp("XenVMMXenVMM", signature) && ((cpuid.eax - base) >= 2)) {
+                        printk("XENBLANKET-DOM0: nested hvm environment detected.\n");
+                        return true;
+                }
+        }
+        printk("XENBLANKET-DOM0: fail to detect nested hvm environment, cpuid %s.\n", signature);
+        return false;
+}
+
+static void xenblanket_get_shared_info(void)
+{
+        struct xen_add_to_physmap xatp;
+	static struct shared_info *shared_info_page = 0;
+
+        shared_info_page = page_address(alloc_pages(GFP_ATOMIC, 0));
+	printk("XENBLAKENT-DOM0: debug xenblanket_get_shared_info: %p %lx %lx.\n",
+	    shared_info_page, __pa(shared_info_page) >> PAGE_SHIFT,
+	    pfn_to_mfn(__pa(shared_info_page) >> PAGE_SHIFT)); 
+	memset(shared_info_page, 0, PAGE_SIZE);
+        xatp.domid = DOMID_SELF;
+        xatp.idx = 0;
+        xatp.space = XENMAPSPACE_shared_info;
+        xatp.gpfn = pfn_to_mfn(__pa(shared_info_page) >> PAGE_SHIFT);
+        if (HYPERVISOR_blanket_memory_op(XENMEM_add_to_physmap, &xatp))
+                BUG();
+
+        HYPERVISOR_shared_info_hvm = shared_info_page;
+
+	printk("XENBLANKET-DOM0: debug shared info page wc - %lx %lx %lx.\n",
+	    HYPERVISOR_shared_info_hvm->wc.version,
+	    HYPERVISOR_shared_info_hvm->wc.sec,
+	    HYPERVISOR_shared_info_hvm->wc.nsec);
+
+	printk("XENBLANKET-DOM0: shared info page - %p.\n", HYPERVISOR_shared_info_hvm);
+}
+
+static void xenblanket_init(void)
+{
+	if(xen_blanket_platform())
+		xenblanket_platform = 1;
+	else
+		xenblanket_platform = 0;
+	if(xenblanket_platform)
+	{
+		printk("XENBLANKET-DOM0: initialize xenblanket hypercalls.\n");
+		HYPERVISOR_blanket_init_nested_hypercall();		
+		xenblanket_get_shared_info();	
+	}
+}
+
+static unsigned long alloc_xen_mmio_hvm(unsigned long len)
 {
 	unsigned long addr;
 
@@ -77,7 +155,7 @@
 
 static irqreturn_t do_hvm_evtchn_intr(int irq, void *dev_id)
 {
-	xen_hvm_evtchn_do_upcall();
+	xen_hvm_evtchn_do_upcall_hvm();
 	return IRQ_HANDLED;
 }
 
@@ -91,9 +169,9 @@
 static int platform_pci_resume(struct pci_dev *pdev)
 {
 	int err;
-	if (xen_have_vector_callback)
+	if (xen_have_vector_callback_hvm)
 		return 0;
-	err = xen_set_callback_via(callback_via);
+	err = xen_set_callback_via_hvm(callback_via);
 	if (err) {
 		dev_err(&pdev->dev, "platform_pci_resume failure!\n");
 		return err;
@@ -109,6 +187,8 @@
 	long mmio_addr, mmio_len;
 	unsigned int max_nr_gframes;
 
+        printk("XENBLANKET-DOM0: platform_pci_init().\n");
+
 	i = pci_enable_device(pdev);
 	if (i)
 		return i;
@@ -135,14 +215,28 @@
 	platform_mmio = mmio_addr;
 	platform_mmiolen = mmio_len;
 
-	if (!xen_have_vector_callback) {
+        xenblanket_init();
+        if(xenblanket_platform)
+                xen_unplug_emulated_devices_hvm();
+        if (!xen_platform_pci_unplug)
+                return -ENODEV;
+
+	xen_setup_features_hvm();
+
+	//L2 Xen cannot recognize callback vector
+        //if (xen_feature_hvm(XENFEAT_hvm_callback_vector))
+        //        xen_have_vector_callback_hvm = 1;	
+
+	xen_init_IRQ_hvm();
+
+	if (!xen_have_vector_callback_hvm) {
 		ret = xen_allocate_irq(pdev);
 		if (ret) {
 			dev_warn(&pdev->dev, "request_irq failed err=%d\n", ret);
 			goto out;
 		}
 		callback_via = get_callback_via(pdev);
-		ret = xen_set_callback_via(callback_via);
+		ret = xen_set_callback_via_hvm(callback_via);
 		if (ret) {
 			dev_warn(&pdev->dev, "Unable to set the evtchn callback "
 					 "err=%d\n", ret);
@@ -150,12 +244,25 @@
 		}
 	}
 
-	max_nr_gframes = gnttab_max_grant_frames();
-	xen_hvm_resume_frames = alloc_xen_mmio(PAGE_SIZE * max_nr_gframes);
-	ret = gnttab_init();
+	max_nr_gframes = gnttab_max_grant_frames_hvm();
+	xen_hvm_resume_frames_hvm = alloc_xen_mmio_hvm(PAGE_SIZE * max_nr_gframes);
+	ret = gnttab_init_hvm();
 	if (ret)
 		goto out;
-	xenbus_probe(NULL);
+
+	xenbus_init_hvm();
+
+	//xenbus_probe_backend_init_hvm();
+
+	xenbus_probe_frontend_init_hvm();
+
+	xen_setup_shutdown_event_hvm();
+
+	xenbus_probe_hvm(NULL);
+
+	xenblanket_platform_initialized = 1;
+
+	xlblk_init_hvm();
 	return 0;
 
 out:
@@ -184,14 +291,11 @@
 #endif
 };
 
-static int __init platform_pci_module_init(void)
+static int __init platform_pci_module_init_hvm(void)
 {
 	/* no unplug has been done, IGNORE hasn't been specified: just
 	 * return now */
-	if (!xen_platform_pci_unplug)
-		return -ENODEV;
-
 	return pci_register_driver(&platform_driver);
 }
 
-module_init(platform_pci_module_init);
+module_init(platform_pci_module_init_hvm);
diff -Nur linux-3.1.2/drivers/xen-blanket/xen-ops.h linux-3.1.2-xenblanket/drivers/xen-blanket/xen-ops.h
--- linux-3.1.2/drivers/xen-blanket/xen-ops.h	2012-04-09 05:27:46.615422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xen-ops.h	2012-03-02 20:28:45.000000000 -0500
@@ -15,7 +15,7 @@
 void xen_timer_resume(void);
 void xen_arch_resume(void);
 
-int xen_setup_shutdown_event(void);
+int xen_setup_shutdown_event_hvm(void);
 
 extern unsigned long *xen_contiguous_bitmap;
 int xen_create_contiguous_region(unsigned long vstart, unsigned int order,
diff -Nur linux-3.1.2/drivers/xen-blanket/xenblanket.h linux-3.1.2-xenblanket/drivers/xen-blanket/xenblanket.h
--- linux-3.1.2/drivers/xen-blanket/xenblanket.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenblanket.h	2012-03-02 20:28:44.000000000 -0500
@@ -0,0 +1,19 @@
+#ifndef XENBLANKET
+#define XENBLANKET
+
+#define __HYPERVISOR_blanket_get_cpuid    39
+#define __HYPERVISOR_blanket_init_nested_hypercall      40      /* 40 */
+#define __HYPERVISOR_blanket_xen_version                41               
+#define __HYPERVISOR_blanket_memory_op                  42                 
+#define __HYPERVISOR_blanket_hvm_op                     43                   
+#define __HYPERVISOR_blanket_grant_table_op             44           
+#define __HYPERVISOR_blanket_event_channel_op           45      /* 45 */
+#define __HYPERVISOR_blanket_sched_op                   46
+
+extern int xenblanket_platform;
+extern volatile struct shared_info * volatile HYPERVISOR_shared_info_hvm;
+extern int xenblanket_platform_initialized;
+
+int __init xlblk_init_hvm(void);
+
+#endif
diff -Nur linux-3.1.2/drivers/xen-blanket/xenblanket_hypercall.h linux-3.1.2-xenblanket/drivers/xen-blanket/xenblanket_hypercall.h
--- linux-3.1.2/drivers/xen-blanket/xenblanket_hypercall.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenblanket_hypercall.h	2012-03-02 20:28:44.000000000 -0500
@@ -0,0 +1,65 @@
+#ifndef _ASM_X86_XENBLANKET_HYPERCALL_H
+#define _ASM_X86_XENBLANKET_HYPERCALL_H
+
+#include "xenblanket.h"
+
+struct blanket_get_cpuid {
+    uint32_t eax;
+    uint32_t ebx;
+    uint32_t ecx;
+    uint32_t edx;
+};
+
+
+static inline long
+HYPERVISOR_blanket_get_cpuid(
+        uint32_t base,
+        struct blanket_get_cpuid *arg)
+{
+        return _hypercall2(long, blanket_get_cpuid, base, arg);
+}
+
+static inline long
+HYPERVISOR_blanket_init_nested_hypercall(void)
+{
+        return _hypercall0(long, blanket_init_nested_hypercall);
+}
+
+static inline long
+HYPERVISOR_blanket_xen_version(int cmd, void *arg)
+{
+        return _hypercall2(long, blanket_xen_version, cmd, arg);
+}
+
+static inline long
+HYPERVISOR_blanket_grant_table_op(unsigned int cmd, void *uop, unsigned int count)
+{
+        return _hypercall3(long, blanket_grant_table_op, cmd, uop, count);
+}
+
+static inline long
+HYPERVISOR_blanket_memory_op(unsigned int cmd, void *arg)
+{
+        return _hypercall2(long, blanket_memory_op, cmd, arg);
+}
+
+static inline long
+HYPERVISOR_blanket_hvm_op(int op, void *arg)
+{
+       return _hypercall2(long, blanket_hvm_op, op, arg);
+}
+
+static inline long
+HYPERVISOR_blanket_event_channel_op(int cmd, void *arg)
+{
+        return _hypercall2(long, blanket_event_channel_op, cmd, arg);
+}
+
+static inline long
+HYPERVISOR_blanket_sched_op(int cmd, void *arg)
+{
+        return _hypercall2(long, blanket_sched_op, cmd, arg);
+}
+
+#endif
+
diff -Nur linux-3.1.2/drivers/xen-blanket/xenblanket_platform.c linux-3.1.2-xenblanket/drivers/xen-blanket/xenblanket_platform.c
--- linux-3.1.2/drivers/xen-blanket/xenblanket_platform.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenblanket_platform.c	2012-03-02 20:28:44.000000000 -0500
@@ -0,0 +1,41 @@
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/preempt.h>
+#include <linux/hardirq.h>
+#include <linux/percpu.h>
+#include <linux/delay.h>
+#include <linux/start_kernel.h>
+#include <linux/sched.h>
+#include <linux/kprobes.h>
+#include <linux/bootmem.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/page-flags.h>
+#include <linux/highmem.h>
+#include <linux/console.h>
+#include <linux/pci.h>
+#include <linux/gfp.h>
+#include <linux/memblock.h>
+
+#include <xen/xen.h>
+#include <xen/interface/xen.h>
+#include <xen/interface/version.h>
+#include <xen/interface/physdev.h>
+#include <xen/interface/vcpu.h>
+#include <xen/interface/memory.h>
+#include <xen/features.h>
+#include <xen/page.h>
+#include <xen/hvm.h>
+#include "xenblanket.h"
+
+int xenblanket_platform;
+EXPORT_SYMBOL_GPL(xenblanket_platform);
+
+volatile struct shared_info * volatile HYPERVISOR_shared_info_hvm;
+EXPORT_SYMBOL_GPL(HYPERVISOR_shared_info_hvm);
+
+int xen_have_vector_callback_hvm;
+EXPORT_SYMBOL_GPL(xen_have_vector_callback_hvm);
+
+int xenblanket_platform_initialized;
+EXPORT_SYMBOL_GPL(xenblanket_platform_initialized);
diff -Nur linux-3.1.2/drivers/xen-blanket/xenbus/Makefile linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/Makefile
--- linux-3.1.2/drivers/xen-blanket/xenbus/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/Makefile	2012-03-02 20:28:44.000000000 -0500
@@ -0,0 +1,12 @@
+obj-y   += xenbus.o
+
+xenbus-objs =
+xenbus-objs += xenbus_client.o
+xenbus-objs += xenbus_comms.o
+xenbus-objs += xenbus_xs.o
+xenbus-objs += xenbus_probe.o
+
+#xenbus-be-objs-y += xenbus_probe_backend.o
+#xenbus-objs += $(xenbus-be-objs-y)
+
+obj-y += xenbus_probe_frontend.o
diff -Nur linux-3.1.2/drivers/xen-blanket/xenbus/xenbus.h linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus.h
--- linux-3.1.2/drivers/xen-blanket/xenbus/xenbus.h	2012-04-09 05:27:46.641422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus.h	2012-03-02 20:28:44.000000000 -0500
@@ -105,28 +105,28 @@
 	return container_of(drv, struct xenbus_driver, driver);
 }
 
-int __must_check __xenbus_register_frontend(struct xenbus_driver *drv,
+int __must_check __xenbus_register_frontend_hvm(struct xenbus_driver *drv,
 					    struct module *owner,
 					    const char *mod_name);
 
 static inline int __must_check
-xenbus_register_frontend(struct xenbus_driver *drv)
+xenbus_register_frontend_hvm(struct xenbus_driver *drv)
 {
 	WARN_ON(drv->owner != THIS_MODULE);
-	return __xenbus_register_frontend(drv, THIS_MODULE, KBUILD_MODNAME);
+	return __xenbus_register_frontend_hvm(drv, THIS_MODULE, KBUILD_MODNAME);
 }
 
-int __must_check __xenbus_register_backend(struct xenbus_driver *drv,
+int __must_check __xenbus_register_backend_hvm(struct xenbus_driver *drv,
 					   struct module *owner,
 					   const char *mod_name);
 static inline int __must_check
-xenbus_register_backend(struct xenbus_driver *drv)
+xenbus_register_backend_hvm(struct xenbus_driver *drv)
 {
 	WARN_ON(drv->owner != THIS_MODULE);
-	return __xenbus_register_backend(drv, THIS_MODULE, KBUILD_MODNAME);
+	return __xenbus_register_backend_hvm(drv, THIS_MODULE, KBUILD_MODNAME);
 }
 
-void xenbus_unregister_driver(struct xenbus_driver *drv);
+void xenbus_unregister_driver_hvm(struct xenbus_driver *drv);
 
 struct xenbus_transaction
 {
@@ -136,55 +136,55 @@
 /* Nil transaction ID. */
 #define XBT_NIL ((struct xenbus_transaction) { 0 })
 
-char **xenbus_directory(struct xenbus_transaction t,
+char **xenbus_directory_hvm(struct xenbus_transaction t,
 			const char *dir, const char *node, unsigned int *num);
-void *xenbus_read(struct xenbus_transaction t,
+void *xenbus_read_hvm(struct xenbus_transaction t,
 		  const char *dir, const char *node, unsigned int *len);
-int xenbus_write(struct xenbus_transaction t,
+int xenbus_write_hvm(struct xenbus_transaction t,
 		 const char *dir, const char *node, const char *string);
-int xenbus_mkdir(struct xenbus_transaction t,
+int xenbus_mkdir_hvm(struct xenbus_transaction t,
 		 const char *dir, const char *node);
-int xenbus_exists(struct xenbus_transaction t,
+int xenbus_exists_hvm(struct xenbus_transaction t,
 		  const char *dir, const char *node);
-int xenbus_rm(struct xenbus_transaction t, const char *dir, const char *node);
-int xenbus_transaction_start(struct xenbus_transaction *t);
-int xenbus_transaction_end(struct xenbus_transaction t, int abort);
+int xenbus_rm_hvm(struct xenbus_transaction t, const char *dir, const char *node);
+int xenbus_transaction_start_hvm(struct xenbus_transaction *t);
+int xenbus_transaction_end_hvm(struct xenbus_transaction t, int abort);
 
 /* Single read and scanf: returns -errno or num scanned if > 0. */
-int xenbus_scanf(struct xenbus_transaction t,
+int xenbus_scanf_hvm(struct xenbus_transaction t,
 		 const char *dir, const char *node, const char *fmt, ...)
 	__attribute__((format(scanf, 4, 5)));
 
 /* Single printf and write: returns -errno or 0. */
-int xenbus_printf(struct xenbus_transaction t,
+int xenbus_printf_hvm(struct xenbus_transaction t,
 		  const char *dir, const char *node, const char *fmt, ...)
 	__attribute__((format(printf, 4, 5)));
 
 /* Generic read function: NULL-terminated triples of name,
  * sprintf-style type string, and pointer. Returns 0 or errno.*/
-int xenbus_gather(struct xenbus_transaction t, const char *dir, ...);
+int xenbus_gather_hvm(struct xenbus_transaction t, const char *dir, ...);
 
 /* notifer routines for when the xenstore comes up */
-extern int xenstored_ready;
-int register_xenstore_notifier(struct notifier_block *nb);
-void unregister_xenstore_notifier(struct notifier_block *nb);
-
-int register_xenbus_watch(struct xenbus_watch *watch);
-void unregister_xenbus_watch(struct xenbus_watch *watch);
-void xs_suspend(void);
-void xs_resume(void);
-void xs_suspend_cancel(void);
+extern int xenstored_ready_hvm;
+int register_xenstore_notifier_hvm(struct notifier_block *nb);
+void unregister_xenstore_notifier_hvm(struct notifier_block *nb);
+
+int register_xenbus_watch_hvm(struct xenbus_watch *watch);
+void unregister_xenbus_watch_hvm(struct xenbus_watch *watch);
+void xs_suspend_hvm(void);
+void xs_resume_hvm(void);
+void xs_suspend_cancel_hvm(void);
 
 /* Used by xenbus_dev to borrow kernel's store connection. */
-void *xenbus_dev_request_and_reply(struct xsd_sockmsg *msg);
+void *xenbus_dev_request_and_reply_hvm(struct xsd_sockmsg *msg);
 
 struct work_struct;
 
 /* Prepare for domain suspend: then resume or cancel the suspend. */
-void xenbus_suspend(void);
-void xenbus_resume(void);
-void xenbus_probe(struct work_struct *);
-void xenbus_suspend_cancel(void);
+void xenbus_suspend_hvm(void);
+void xenbus_resume_hvm(void);
+void xenbus_probe_hvm(struct work_struct *);
+void xenbus_suspend_cancel_hvm(void);
 
 #define XENBUS_IS_ERR_READ(str) ({			\
 	if (!IS_ERR(str) && strlen(str) == 0) {		\
@@ -196,40 +196,44 @@
 
 #define XENBUS_EXIST_ERR(err) ((err) == -ENOENT || (err) == -ERANGE)
 
-int xenbus_watch_path(struct xenbus_device *dev, const char *path,
+int xenbus_watch_path_hvm(struct xenbus_device *dev, const char *path,
 		      struct xenbus_watch *watch,
 		      void (*callback)(struct xenbus_watch *,
 				       const char **, unsigned int));
-int xenbus_watch_pathfmt(struct xenbus_device *dev, struct xenbus_watch *watch,
+int xenbus_watch_pathfmt_hvm(struct xenbus_device *dev, struct xenbus_watch *watch,
 			 void (*callback)(struct xenbus_watch *,
 					  const char **, unsigned int),
 			 const char *pathfmt, ...)
 	__attribute__ ((format (printf, 4, 5)));
 
-int xenbus_switch_state(struct xenbus_device *dev, enum xenbus_state new_state);
-int xenbus_grant_ring(struct xenbus_device *dev, unsigned long ring_mfn);
-int xenbus_map_ring_valloc(struct xenbus_device *dev,
+int xenbus_switch_state_hvm(struct xenbus_device *dev, enum xenbus_state new_state);
+int xenbus_grant_ring_hvm(struct xenbus_device *dev, unsigned long ring_mfn);
+int xenbus_map_ring_valloc_hvm(struct xenbus_device *dev,
 			   int gnt_ref, void **vaddr);
-int xenbus_map_ring(struct xenbus_device *dev, int gnt_ref,
+int xenbus_map_ring_hvm(struct xenbus_device *dev, int gnt_ref,
 			   grant_handle_t *handle, void *vaddr);
 
-int xenbus_unmap_ring_vfree(struct xenbus_device *dev, void *vaddr);
-int xenbus_unmap_ring(struct xenbus_device *dev,
+int xenbus_unmap_ring_vfree_hvm(struct xenbus_device *dev, void *vaddr);
+int xenbus_unmap_ring_hvm(struct xenbus_device *dev,
 		      grant_handle_t handle, void *vaddr);
 
-int xenbus_alloc_evtchn(struct xenbus_device *dev, int *port);
-int xenbus_bind_evtchn(struct xenbus_device *dev, int remote_port, int *port);
-int xenbus_free_evtchn(struct xenbus_device *dev, int port);
+int xenbus_alloc_evtchn_hvm(struct xenbus_device *dev, int *port);
+int xenbus_bind_evtchn_hvm(struct xenbus_device *dev, int remote_port, int *port);
+int xenbus_free_evtchn_hvm(struct xenbus_device *dev, int port);
 
-enum xenbus_state xenbus_read_driver_state(const char *path);
+enum xenbus_state xenbus_read_driver_state_hvm(const char *path);
 
 __attribute__((format(printf, 3, 4)))
-void xenbus_dev_error(struct xenbus_device *dev, int err, const char *fmt, ...);
+void xenbus_dev_error_hvm(struct xenbus_device *dev, int err, const char *fmt, ...);
 __attribute__((format(printf, 3, 4)))
-void xenbus_dev_fatal(struct xenbus_device *dev, int err, const char *fmt, ...);
+void xenbus_dev_fatal_hvm(struct xenbus_device *dev, int err, const char *fmt, ...);
 
-const char *xenbus_strstate(enum xenbus_state state);
-int xenbus_dev_is_online(struct xenbus_device *dev);
-int xenbus_frontend_closed(struct xenbus_device *dev);
+const char *xenbus_strstate_hvm(enum xenbus_state state);
+int xenbus_dev_is_online_hvm(struct xenbus_device *dev);
+int xenbus_frontend_closed_hvm(struct xenbus_device *dev);
+
+int __init xenbus_init_hvm(void);
+int __init xenbus_probe_backend_init_hvm(void);
+int __init xenbus_probe_frontend_init_hvm(void);
 
 #endif /* _XEN_XENBUS_H */
diff -Nur linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_client.c linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_client.c
--- linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_client.c	2012-04-09 05:27:46.629422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_client.c	2012-03-02 20:28:44.000000000 -0500
@@ -36,11 +36,14 @@
 #include <asm/xen/hypervisor.h>
 #include <xen/interface/xen.h>
 #include <xen/interface/event_channel.h>
-#include <xen/events.h>
-#include <xen/grant_table.h>
-#include <xen/xenbus.h>
+#include "../events.h"
+#include "../grant_table.h"
+#include "xenbus.h"
 
-const char *xenbus_strstate(enum xenbus_state state)
+#include "../xenblanket.h"
+#include "../xenblanket_hypercall.h"
+
+const char *xenbus_strstate_hvm(enum xenbus_state state)
 {
 	static const char *const name[] = {
 		[ XenbusStateUnknown      ] = "Unknown",
@@ -55,7 +58,7 @@
 	};
 	return (state < ARRAY_SIZE(name)) ? name[state] : "INVALID";
 }
-EXPORT_SYMBOL_GPL(xenbus_strstate);
+EXPORT_SYMBOL_GPL(xenbus_strstate_hvm);
 
 /**
  * xenbus_watch_path - register a watch
@@ -71,7 +74,7 @@
  * be NULL, the device will switch to %XenbusStateClosing, and the error will
  * be saved in the store.
  */
-int xenbus_watch_path(struct xenbus_device *dev, const char *path,
+int xenbus_watch_path_hvm(struct xenbus_device *dev, const char *path,
 		      struct xenbus_watch *watch,
 		      void (*callback)(struct xenbus_watch *,
 				       const char **, unsigned int))
@@ -81,17 +84,17 @@
 	watch->node = path;
 	watch->callback = callback;
 
-	err = register_xenbus_watch(watch);
+	err = register_xenbus_watch_hvm(watch);
 
 	if (err) {
 		watch->node = NULL;
 		watch->callback = NULL;
-		xenbus_dev_fatal(dev, err, "adding watch on %s", path);
+		xenbus_dev_fatal_hvm(dev, err, "adding watch on %s", path);
 	}
 
 	return err;
 }
-EXPORT_SYMBOL_GPL(xenbus_watch_path);
+EXPORT_SYMBOL_GPL(xenbus_watch_path_hvm);
 
 
 /**
@@ -109,7 +112,7 @@
  * free, the device will switch to %XenbusStateClosing, and the error will be
  * saved in the store.
  */
-int xenbus_watch_pathfmt(struct xenbus_device *dev,
+int xenbus_watch_pathfmt_hvm(struct xenbus_device *dev,
 			 struct xenbus_watch *watch,
 			 void (*callback)(struct xenbus_watch *,
 					const char **, unsigned int),
@@ -124,16 +127,16 @@
 	va_end(ap);
 
 	if (!path) {
-		xenbus_dev_fatal(dev, -ENOMEM, "allocating path for watch");
+		xenbus_dev_fatal_hvm(dev, -ENOMEM, "allocating path for watch");
 		return -ENOMEM;
 	}
-	err = xenbus_watch_path(dev, path, watch, callback);
+	err = xenbus_watch_path_hvm(dev, path, watch, callback);
 
 	if (err)
 		kfree(path);
 	return err;
 }
-EXPORT_SYMBOL_GPL(xenbus_watch_pathfmt);
+EXPORT_SYMBOL_GPL(xenbus_watch_pathfmt_hvm);
 
 static void xenbus_switch_fatal(struct xenbus_device *, int, int,
 				const char *, ...);
@@ -165,17 +168,17 @@
 again:
 	abort = 1;
 
-	err = xenbus_transaction_start(&xbt);
+	err = xenbus_transaction_start_hvm(&xbt);
 	if (err) {
 		xenbus_switch_fatal(dev, depth, err, "starting transaction");
 		return 0;
 	}
 
-	err = xenbus_scanf(xbt, dev->nodename, "state", "%d", &current_state);
+	err = xenbus_scanf_hvm(xbt, dev->nodename, "state", "%d", &current_state);
 	if (err != 1)
 		goto abort;
 
-	err = xenbus_printf(xbt, dev->nodename, "state", "%d", state);
+	err = xenbus_printf_hvm(xbt, dev->nodename, "state", "%d", state);
 	if (err) {
 		xenbus_switch_fatal(dev, depth, err, "writing new state");
 		goto abort;
@@ -183,7 +186,7 @@
 
 	abort = 0;
 abort:
-	err = xenbus_transaction_end(xbt, abort);
+	err = xenbus_transaction_end_hvm(xbt, abort);
 	if (err) {
 		if (err == -EAGAIN && !abort)
 			goto again;
@@ -203,20 +206,20 @@
  * Return 0 on success, or -errno on error.  On error, the device will switch
  * to XenbusStateClosing, and the error will be saved in the store.
  */
-int xenbus_switch_state(struct xenbus_device *dev, enum xenbus_state state)
+int xenbus_switch_state_hvm(struct xenbus_device *dev, enum xenbus_state state)
 {
 	return __xenbus_switch_state(dev, state, 0);
 }
 
-EXPORT_SYMBOL_GPL(xenbus_switch_state);
+EXPORT_SYMBOL_GPL(xenbus_switch_state_hvm);
 
-int xenbus_frontend_closed(struct xenbus_device *dev)
+int xenbus_frontend_closed_hvm(struct xenbus_device *dev)
 {
-	xenbus_switch_state(dev, XenbusStateClosed);
+	xenbus_switch_state_hvm(dev, XenbusStateClosed);
 	complete(&dev->down);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(xenbus_frontend_closed);
+EXPORT_SYMBOL_GPL(xenbus_frontend_closed_hvm);
 
 /**
  * Return the path to the error node for the given device, or NULL on failure.
@@ -256,7 +259,7 @@
 		goto fail;
 	}
 
-	if (xenbus_write(XBT_NIL, path_buffer, "error", printf_buffer) != 0) {
+	if (xenbus_write_hvm(XBT_NIL, path_buffer, "error", printf_buffer) != 0) {
 		dev_err(&dev->dev, "failed to write error node for %s (%s)\n",
 		       dev->nodename, printf_buffer);
 		goto fail;
@@ -277,7 +280,7 @@
  * Report the given negative errno into the store, along with the given
  * formatted message.
  */
-void xenbus_dev_error(struct xenbus_device *dev, int err, const char *fmt, ...)
+void xenbus_dev_error_hvm(struct xenbus_device *dev, int err, const char *fmt, ...)
 {
 	va_list ap;
 
@@ -285,7 +288,7 @@
 	xenbus_va_dev_error(dev, err, fmt, ap);
 	va_end(ap);
 }
-EXPORT_SYMBOL_GPL(xenbus_dev_error);
+EXPORT_SYMBOL_GPL(xenbus_dev_error_hvm);
 
 /**
  * xenbus_dev_fatal
@@ -298,7 +301,7 @@
  * closedown of this driver and its peer.
  */
 
-void xenbus_dev_fatal(struct xenbus_device *dev, int err, const char *fmt, ...)
+void xenbus_dev_fatal_hvm(struct xenbus_device *dev, int err, const char *fmt, ...)
 {
 	va_list ap;
 
@@ -306,9 +309,9 @@
 	xenbus_va_dev_error(dev, err, fmt, ap);
 	va_end(ap);
 
-	xenbus_switch_state(dev, XenbusStateClosing);
+	xenbus_switch_state_hvm(dev, XenbusStateClosing);
 }
-EXPORT_SYMBOL_GPL(xenbus_dev_fatal);
+EXPORT_SYMBOL_GPL(xenbus_dev_fatal_hvm);
 
 /**
  * Equivalent to xenbus_dev_fatal(dev, err, fmt, args), but helps
@@ -336,14 +339,14 @@
  * 0 on success, or -errno on error.  On error, the device will switch to
  * XenbusStateClosing, and the error will be saved in the store.
  */
-int xenbus_grant_ring(struct xenbus_device *dev, unsigned long ring_mfn)
+int xenbus_grant_ring_hvm(struct xenbus_device *dev, unsigned long ring_mfn)
 {
-	int err = gnttab_grant_foreign_access(dev->otherend_id, ring_mfn, 0);
+	int err = gnttab_grant_foreign_access_hvm(dev->otherend_id, ring_mfn, 0);
 	if (err < 0)
-		xenbus_dev_fatal(dev, err, "granting access to ring page");
+		xenbus_dev_fatal_hvm(dev, err, "granting access to ring page");
 	return err;
 }
-EXPORT_SYMBOL_GPL(xenbus_grant_ring);
+EXPORT_SYMBOL_GPL(xenbus_grant_ring_hvm);
 
 
 /**
@@ -352,7 +355,7 @@
  * error, the device will switch to XenbusStateClosing, and the error will be
  * saved in the store.
  */
-int xenbus_alloc_evtchn(struct xenbus_device *dev, int *port)
+int xenbus_alloc_evtchn_hvm(struct xenbus_device *dev, int *port)
 {
 	struct evtchn_alloc_unbound alloc_unbound;
 	int err;
@@ -360,16 +363,16 @@
 	alloc_unbound.dom = DOMID_SELF;
 	alloc_unbound.remote_dom = dev->otherend_id;
 
-	err = HYPERVISOR_event_channel_op(EVTCHNOP_alloc_unbound,
+	err = HYPERVISOR_blanket_event_channel_op(EVTCHNOP_alloc_unbound,
 					  &alloc_unbound);
 	if (err)
-		xenbus_dev_fatal(dev, err, "allocating event channel");
+		xenbus_dev_fatal_hvm(dev, err, "allocating event channel");
 	else
 		*port = alloc_unbound.port;
 
 	return err;
 }
-EXPORT_SYMBOL_GPL(xenbus_alloc_evtchn);
+EXPORT_SYMBOL_GPL(xenbus_alloc_evtchn_hvm);
 
 
 /**
@@ -377,7 +380,7 @@
  * on success and stores the local port in *port. On error, returns -errno,
  * switches the device to XenbusStateClosing, and saves the error in XenStore.
  */
-int xenbus_bind_evtchn(struct xenbus_device *dev, int remote_port, int *port)
+int xenbus_bind_evtchn_hvm(struct xenbus_device *dev, int remote_port, int *port)
 {
 	struct evtchn_bind_interdomain bind_interdomain;
 	int err;
@@ -388,7 +391,7 @@
 	err = HYPERVISOR_event_channel_op(EVTCHNOP_bind_interdomain,
 					  &bind_interdomain);
 	if (err)
-		xenbus_dev_fatal(dev, err,
+		xenbus_dev_fatal_hvm(dev, err,
 				 "binding to event channel %d from domain %d",
 				 remote_port, dev->otherend_id);
 	else
@@ -396,78 +399,26 @@
 
 	return err;
 }
-EXPORT_SYMBOL_GPL(xenbus_bind_evtchn);
+EXPORT_SYMBOL_GPL(xenbus_bind_evtchn_hvm);
 
 
 /**
  * Free an existing event channel. Returns 0 on success or -errno on error.
  */
-int xenbus_free_evtchn(struct xenbus_device *dev, int port)
+int xenbus_free_evtchn_hvm(struct xenbus_device *dev, int port)
 {
 	struct evtchn_close close;
 	int err;
 
 	close.port = port;
 
-	err = HYPERVISOR_event_channel_op(EVTCHNOP_close, &close);
+	err = HYPERVISOR_blanket_event_channel_op(EVTCHNOP_close, &close);
 	if (err)
-		xenbus_dev_error(dev, err, "freeing event channel %d", port);
+		xenbus_dev_error_hvm(dev, err, "freeing event channel %d", port);
 
 	return err;
 }
-EXPORT_SYMBOL_GPL(xenbus_free_evtchn);
-
-
-/**
- * xenbus_map_ring_valloc
- * @dev: xenbus device
- * @gnt_ref: grant reference
- * @vaddr: pointer to address to be filled out by mapping
- *
- * Based on Rusty Russell's skeleton driver's map_page.
- * Map a page of memory into this domain from another domain's grant table.
- * xenbus_map_ring_valloc allocates a page of virtual address space, maps the
- * page to that address, and sets *vaddr to that address.
- * Returns 0 on success, and GNTST_* (see xen/include/interface/grant_table.h)
- * or -ENOMEM on error. If an error is returned, device will switch to
- * XenbusStateClosing and the error message will be saved in XenStore.
- */
-int xenbus_map_ring_valloc(struct xenbus_device *dev, int gnt_ref, void **vaddr)
-{
-	struct gnttab_map_grant_ref op = {
-		.flags = GNTMAP_host_map,
-		.ref   = gnt_ref,
-		.dom   = dev->otherend_id,
-	};
-	struct vm_struct *area;
-
-	*vaddr = NULL;
-
-	area = xen_alloc_vm_area(PAGE_SIZE);
-	if (!area)
-		return -ENOMEM;
-
-	op.host_addr = (unsigned long)area->addr;
-
-	if (HYPERVISOR_grant_table_op(GNTTABOP_map_grant_ref, &op, 1))
-		BUG();
-
-	if (op.status != GNTST_okay) {
-		xen_free_vm_area(area);
-		xenbus_dev_fatal(dev, op.status,
-				 "mapping in shared page %d from domain %d",
-				 gnt_ref, dev->otherend_id);
-		return op.status;
-	}
-
-	/* Stuff the handle in an unused field */
-	area->phys_addr = (unsigned long)op.handle;
-
-	*vaddr = area->addr;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(xenbus_map_ring_valloc);
-
+EXPORT_SYMBOL_GPL(xenbus_free_evtchn_hvm);
 
 /**
  * xenbus_map_ring
@@ -483,7 +434,7 @@
  * or -ENOMEM on error. If an error is returned, device will switch to
  * XenbusStateClosing and the error message will be saved in XenStore.
  */
-int xenbus_map_ring(struct xenbus_device *dev, int gnt_ref,
+int xenbus_map_ring_hvm(struct xenbus_device *dev, int gnt_ref,
 		    grant_handle_t *handle, void *vaddr)
 {
 	struct gnttab_map_grant_ref op = {
@@ -497,7 +448,7 @@
 		BUG();
 
 	if (op.status != GNTST_okay) {
-		xenbus_dev_fatal(dev, op.status,
+		xenbus_dev_fatal_hvm(dev, op.status,
 				 "mapping in shared page %d from domain %d",
 				 gnt_ref, dev->otherend_id);
 	} else
@@ -505,63 +456,7 @@
 
 	return op.status;
 }
-EXPORT_SYMBOL_GPL(xenbus_map_ring);
-
-
-/**
- * xenbus_unmap_ring_vfree
- * @dev: xenbus device
- * @vaddr: addr to unmap
- *
- * Based on Rusty Russell's skeleton driver's unmap_page.
- * Unmap a page of memory in this domain that was imported from another domain.
- * Use xenbus_unmap_ring_vfree if you mapped in your memory with
- * xenbus_map_ring_valloc (it will free the virtual address space).
- * Returns 0 on success and returns GNTST_* on error
- * (see xen/include/interface/grant_table.h).
- */
-int xenbus_unmap_ring_vfree(struct xenbus_device *dev, void *vaddr)
-{
-	struct vm_struct *area;
-	struct gnttab_unmap_grant_ref op = {
-		.host_addr = (unsigned long)vaddr,
-	};
-
-	/* It'd be nice if linux/vmalloc.h provided a find_vm_area(void *addr)
-	 * method so that we don't have to muck with vmalloc internals here.
-	 * We could force the user to hang on to their struct vm_struct from
-	 * xenbus_map_ring_valloc, but these 6 lines considerably simplify
-	 * this API.
-	 */
-	read_lock(&vmlist_lock);
-	for (area = vmlist; area != NULL; area = area->next) {
-		if (area->addr == vaddr)
-			break;
-	}
-	read_unlock(&vmlist_lock);
-
-	if (!area) {
-		xenbus_dev_error(dev, -ENOENT,
-				 "can't find mapped virtual address %p", vaddr);
-		return GNTST_bad_virt_addr;
-	}
-
-	op.handle = (grant_handle_t)area->phys_addr;
-
-	if (HYPERVISOR_grant_table_op(GNTTABOP_unmap_grant_ref, &op, 1))
-		BUG();
-
-	if (op.status == GNTST_okay)
-		xen_free_vm_area(area);
-	else
-		xenbus_dev_error(dev, op.status,
-				 "unmapping page at handle %d error %d",
-				 (int16_t)area->phys_addr, op.status);
-
-	return op.status;
-}
-EXPORT_SYMBOL_GPL(xenbus_unmap_ring_vfree);
-
+EXPORT_SYMBOL_GPL(xenbus_map_ring_hvm);
 
 /**
  * xenbus_unmap_ring
@@ -573,7 +468,7 @@
  * Returns 0 on success and returns GNTST_* on error
  * (see xen/include/interface/grant_table.h).
  */
-int xenbus_unmap_ring(struct xenbus_device *dev,
+int xenbus_unmap_ring_hvm(struct xenbus_device *dev,
 		      grant_handle_t handle, void *vaddr)
 {
 	struct gnttab_unmap_grant_ref op = {
@@ -585,13 +480,13 @@
 		BUG();
 
 	if (op.status != GNTST_okay)
-		xenbus_dev_error(dev, op.status,
+		xenbus_dev_error_hvm(dev, op.status,
 				 "unmapping page at handle %d error %d",
 				 handle, op.status);
 
 	return op.status;
 }
-EXPORT_SYMBOL_GPL(xenbus_unmap_ring);
+EXPORT_SYMBOL_GPL(xenbus_unmap_ring_hvm);
 
 
 /**
@@ -601,13 +496,13 @@
  * Return the state of the driver rooted at the given store path, or
  * XenbusStateUnknown if no state can be read.
  */
-enum xenbus_state xenbus_read_driver_state(const char *path)
+enum xenbus_state xenbus_read_driver_state_hvm(const char *path)
 {
 	enum xenbus_state result;
-	int err = xenbus_gather(XBT_NIL, path, "state", "%d", &result, NULL);
+	int err = xenbus_gather_hvm(XBT_NIL, path, "state", "%d", &result, NULL);
 	if (err)
 		result = XenbusStateUnknown;
 
 	return result;
 }
-EXPORT_SYMBOL_GPL(xenbus_read_driver_state);
+EXPORT_SYMBOL_GPL(xenbus_read_driver_state_hvm);
diff -Nur linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_comms.c linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_comms.c
--- linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_comms.c	2012-04-09 05:27:46.637422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_comms.c	2012-04-09 06:34:03.579422003 -0400
@@ -34,22 +34,22 @@
 #include <linux/interrupt.h>
 #include <linux/sched.h>
 #include <linux/err.h>
-#include <xen/xenbus.h>
+#include "xenbus.h"
 #include <asm/xen/hypervisor.h>
-#include <xen/events.h>
+#include "../events.h"
 #include <xen/page.h>
 #include "xenbus_comms.h"
 
 static int xenbus_irq;
 
-static DECLARE_WORK(probe_work, xenbus_probe);
+static DECLARE_WORK(probe_work, xenbus_probe_hvm);
 
 static DECLARE_WAIT_QUEUE_HEAD(xb_waitq);
 
 static irqreturn_t wake_waiting(int irq, void *unused)
 {
-	if (unlikely(xenstored_ready == 0)) {
-		xenstored_ready = 1;
+	if (unlikely(xenstored_ready_hvm == 0)) {
+		xenstored_ready_hvm = 1;
 		schedule_work(&probe_work);
 	}
 
@@ -89,9 +89,9 @@
  *
  * Returns 0 on success, error otherwise.
  */
-int xb_write(const void *data, unsigned len)
+int xb_write_hvm(const void *data, unsigned len)
 {
-	struct xenstore_domain_interface *intf = xen_store_interface;
+	struct xenstore_domain_interface *intf = xen_store_interface_hvm;
 	XENSTORE_RING_IDX cons, prod;
 	int rc;
 
@@ -132,26 +132,26 @@
 		intf->req_prod += avail;
 
 		/* Implies mb(): other side will see the updated producer. */
-		notify_remote_via_evtchn(xen_store_evtchn);
+		notify_remote_via_evtchn_hvm(xen_store_evtchn_hvm);
 	}
 
 	return 0;
 }
 
-int xb_data_to_read(void)
+int xb_data_to_read_hvm(void)
 {
-	struct xenstore_domain_interface *intf = xen_store_interface;
+	struct xenstore_domain_interface *intf = xen_store_interface_hvm;
 	return (intf->rsp_cons != intf->rsp_prod);
 }
 
-int xb_wait_for_data_to_read(void)
+int xb_wait_for_data_to_read_hvm(void)
 {
-	return wait_event_interruptible(xb_waitq, xb_data_to_read());
+	return wait_event_interruptible(xb_waitq, xb_data_to_read_hvm());
 }
 
-int xb_read(void *data, unsigned len)
+int xb_read_hvm(void *data, unsigned len)
 {
-	struct xenstore_domain_interface *intf = xen_store_interface;
+	struct xenstore_domain_interface *intf = xen_store_interface_hvm;
 	XENSTORE_RING_IDX cons, prod;
 	int rc;
 
@@ -159,7 +159,7 @@
 		unsigned int avail;
 		const char *src;
 
-		rc = xb_wait_for_data_to_read();
+		rc = xb_wait_for_data_to_read_hvm();
 		if (rc < 0)
 			return rc;
 
@@ -191,7 +191,7 @@
 		pr_debug("Finished read of %i bytes (%i to go)\n", avail, len);
 
 		/* Implies mb(): other side will see the updated consumer. */
-		notify_remote_via_evtchn(xen_store_evtchn);
+		notify_remote_via_evtchn_hvm(xen_store_evtchn_hvm);
 	}
 
 	return 0;
@@ -200,9 +200,9 @@
 /**
  * xb_init_comms - Set up interrupt handler off store event channel.
  */
-int xb_init_comms(void)
+int xb_init_comms_hvm(void)
 {
-	struct xenstore_domain_interface *intf = xen_store_interface;
+	struct xenstore_domain_interface *intf = xen_store_interface_hvm;
 
 	if (intf->req_prod != intf->req_cons)
 		printk(KERN_ERR "XENBUS request ring is not quiescent "
@@ -215,20 +215,18 @@
 		intf->rsp_cons = intf->rsp_prod;
 	}
 
-	if (xenbus_irq) {
-		/* Already have an irq; assume we're resuming */
-		rebind_evtchn_irq(xen_store_evtchn, xenbus_irq);
-	} else {
-		int err;
-		err = bind_evtchn_to_irqhandler(xen_store_evtchn, wake_waiting,
-						0, "xenbus", &xb_waitq);
-		if (err <= 0) {
-			printk(KERN_ERR "XENBUS request irq failed %i\n", err);
-			return err;
-		}
-
-		xenbus_irq = err;
+	/* don't need to consider resume, for dom0's use */
+	int err;
+	err = bind_evtchn_to_irqhandler_hvm(xen_store_evtchn_hvm, wake_waiting,
+					0, "xenbus_xenblanket", &xb_waitq);
+	if (err <= 0) {
+		printk(KERN_ERR "XENBUS request irq failed %i\n", err);
+		return err;
 	}
 
+	printk("XENBLANKET-DOM0: xenbus irq %d.\n", xenbus_irq);
+
+	xenbus_irq = err;
+
 	return 0;
 }
diff -Nur linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_comms.h linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_comms.h
--- linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_comms.h	2012-04-09 05:27:46.637422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_comms.h	2012-03-02 20:28:44.000000000 -0500
@@ -31,16 +31,16 @@
 #ifndef _XENBUS_COMMS_H
 #define _XENBUS_COMMS_H
 
-int xs_init(void);
-int xb_init_comms(void);
+int xs_init_hvm(void);
+int xb_init_comms_hvm(void);
 
 /* Low level routines. */
-int xb_write(const void *data, unsigned len);
-int xb_read(void *data, unsigned len);
-int xb_data_to_read(void);
-int xb_wait_for_data_to_read(void);
-int xs_input_avail(void);
-extern struct xenstore_domain_interface *xen_store_interface;
-extern int xen_store_evtchn;
+int xb_write_hvm(const void *data, unsigned len);
+int xb_read_hvm(void *data, unsigned len);
+int xb_data_to_read_hvm(void);
+int xb_wait_for_data_to_read_hvm(void);
+int xs_input_avail_hvm(void);
+extern struct xenstore_domain_interface *xen_store_interface_hvm;
+extern int xen_store_evtchn_hvm;
 
 #endif /* _XENBUS_COMMS_H */
diff -Nur linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_probe.c linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_probe.c
--- linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_probe.c	2012-04-09 05:27:46.637422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_probe.c	2012-04-09 06:37:09.509422002 -0400
@@ -52,8 +52,8 @@
 #include <asm/xen/hypervisor.h>
 
 #include <xen/xen.h>
-#include <xen/xenbus.h>
-#include <xen/events.h>
+#include "xenbus.h"
+#include "../events.h"
 #include <xen/page.h>
 
 #include <xen/hvm.h>
@@ -61,17 +61,37 @@
 #include "xenbus_comms.h"
 #include "xenbus_probe.h"
 
+#include "../xenblanket.h"
+#include "../xenblanket_hypercall.h"
 
-int xen_store_evtchn;
-EXPORT_SYMBOL_GPL(xen_store_evtchn);
 
-struct xenstore_domain_interface *xen_store_interface;
-EXPORT_SYMBOL_GPL(xen_store_interface);
+int xen_store_evtchn_hvm;
+EXPORT_SYMBOL_GPL(xen_store_evtchn_hvm);
+
+struct xenstore_domain_interface *xen_store_interface_hvm;
+EXPORT_SYMBOL_GPL(xen_store_interface_hvm);
 
 static unsigned long xen_store_mfn;
 
 static BLOCKING_NOTIFIER_HEAD(xenstore_chain);
 
+static inline int hvm_get_parameter_hvm(int idx, uint64_t *value)
+{
+        struct xen_hvm_param xhv;
+        int r;
+
+        xhv.domid = DOMID_SELF;
+        xhv.index = idx;
+        r = HYPERVISOR_blanket_hvm_op(HVMOP_get_param, &xhv);
+        if (r < 0) {
+                printk(KERN_ERR "Cannot get hvm parameter %d: %d!\n",
+                        idx, r);
+                return r;
+        }
+        *value = xhv.value;
+        return r;
+}
+
 /* If something in array of ids matches this device, return it. */
 static const struct xenbus_device_id *
 match_device(const struct xenbus_device_id *arr, struct xenbus_device *dev)
@@ -83,7 +103,7 @@
 	return NULL;
 }
 
-int xenbus_match(struct device *_dev, struct device_driver *_drv)
+int xenbus_match_hvm(struct device *_dev, struct device_driver *_drv)
 {
 	struct xenbus_driver *drv = to_xenbus_driver(_drv);
 
@@ -92,7 +112,7 @@
 
 	return match_device(drv->ids, to_xenbus_device(_dev)) != NULL;
 }
-EXPORT_SYMBOL_GPL(xenbus_match);
+EXPORT_SYMBOL_GPL(xenbus_match_hvm);
 
 
 static void free_otherend_details(struct xenbus_device *dev)
@@ -105,7 +125,7 @@
 static void free_otherend_watch(struct xenbus_device *dev)
 {
 	if (dev->otherend_watch.node) {
-		unregister_xenbus_watch(&dev->otherend_watch);
+		unregister_xenbus_watch_hvm(&dev->otherend_watch);
 		kfree(dev->otherend_watch.node);
 		dev->otherend_watch.node = NULL;
 	}
@@ -129,28 +149,28 @@
 	struct xen_bus_type *bus =
 		container_of(dev->dev.bus, struct xen_bus_type, bus);
 
-	return xenbus_watch_pathfmt(dev, &dev->otherend_watch,
+	return xenbus_watch_pathfmt_hvm(dev, &dev->otherend_watch,
 				    bus->otherend_changed,
 				    "%s/%s", dev->otherend, "state");
 }
 
 
-int xenbus_read_otherend_details(struct xenbus_device *xendev,
+int xenbus_read_otherend_details_hvm(struct xenbus_device *xendev,
 				 char *id_node, char *path_node)
 {
-	int err = xenbus_gather(XBT_NIL, xendev->nodename,
+	int err = xenbus_gather_hvm(XBT_NIL, xendev->nodename,
 				id_node, "%i", &xendev->otherend_id,
 				path_node, NULL, &xendev->otherend,
 				NULL);
 	if (err) {
-		xenbus_dev_fatal(xendev, err,
+		xenbus_dev_fatal_hvm(xendev, err,
 				 "reading other end details from %s",
 				 xendev->nodename);
 		return err;
 	}
 	if (strlen(xendev->otherend) == 0 ||
-	    !xenbus_exists(XBT_NIL, xendev->otherend, "")) {
-		xenbus_dev_fatal(xendev, -ENOENT,
+	    !xenbus_exists_hvm(XBT_NIL, xendev->otherend, "")) {
+		xenbus_dev_fatal_hvm(xendev, -ENOENT,
 				 "unable to read other end from %s.  "
 				 "missing or inaccessible.",
 				 xendev->nodename);
@@ -160,9 +180,9 @@
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(xenbus_read_otherend_details);
+EXPORT_SYMBOL_GPL(xenbus_read_otherend_details_hvm);
 
-void xenbus_otherend_changed(struct xenbus_watch *watch,
+void xenbus_otherend_changed_hvm(struct xenbus_watch *watch,
 			     const char **vec, unsigned int len,
 			     int ignore_on_shutdown)
 {
@@ -181,10 +201,10 @@
 		return;
 	}
 
-	state = xenbus_read_driver_state(dev->otherend);
+	state = xenbus_read_driver_state_hvm(dev->otherend);
 
 	dev_dbg(&dev->dev, "state is %d, (%s), %s, %s\n",
-		state, xenbus_strstate(state), dev->otherend_watch.node,
+		state, xenbus_strstate_hvm(state), dev->otherend_watch.node,
 		vec[XS_WATCH_PATH]);
 
 	/*
@@ -193,16 +213,16 @@
 	 */
 	if (system_state > SYSTEM_RUNNING) {
 		if (ignore_on_shutdown && (state == XenbusStateClosing))
-			xenbus_frontend_closed(dev);
+			xenbus_frontend_closed_hvm(dev);
 		return;
 	}
 
 	if (drv->otherend_changed)
 		drv->otherend_changed(dev, state);
 }
-EXPORT_SYMBOL_GPL(xenbus_otherend_changed);
+EXPORT_SYMBOL_GPL(xenbus_otherend_changed_hvm);
 
-int xenbus_dev_probe(struct device *_dev)
+int xenbus_dev_probe_hvm(struct device *_dev)
 {
 	struct xenbus_device *dev = to_xenbus_device(_dev);
 	struct xenbus_driver *drv = to_xenbus_driver(_dev->driver);
@@ -242,13 +262,13 @@
 
 	return 0;
 fail:
-	xenbus_dev_error(dev, err, "xenbus_dev_probe on %s", dev->nodename);
-	xenbus_switch_state(dev, XenbusStateClosed);
+	xenbus_dev_error_hvm(dev, err, "xenbus_dev_probe on %s", dev->nodename);
+	xenbus_switch_state_hvm(dev, XenbusStateClosed);
 	return err;
 }
-EXPORT_SYMBOL_GPL(xenbus_dev_probe);
+EXPORT_SYMBOL_GPL(xenbus_dev_probe_hvm);
 
-int xenbus_dev_remove(struct device *_dev)
+int xenbus_dev_remove_hvm(struct device *_dev)
 {
 	struct xenbus_device *dev = to_xenbus_device(_dev);
 	struct xenbus_driver *drv = to_xenbus_driver(_dev->driver);
@@ -261,12 +281,12 @@
 	if (drv->remove)
 		drv->remove(dev);
 
-	xenbus_switch_state(dev, XenbusStateClosed);
+	xenbus_switch_state_hvm(dev, XenbusStateClosed);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(xenbus_dev_remove);
+EXPORT_SYMBOL_GPL(xenbus_dev_remove_hvm);
 
-void xenbus_dev_shutdown(struct device *_dev)
+void xenbus_dev_shutdown_hvm(struct device *_dev)
 {
 	struct xenbus_device *dev = to_xenbus_device(_dev);
 	unsigned long timeout = 5*HZ;
@@ -276,10 +296,10 @@
 	get_device(&dev->dev);
 	if (dev->state != XenbusStateConnected) {
 		printk(KERN_INFO "%s: %s: %s != Connected, skipping\n", __func__,
-		       dev->nodename, xenbus_strstate(dev->state));
+		       dev->nodename, xenbus_strstate_hvm(dev->state));
 		goto out;
 	}
-	xenbus_switch_state(dev, XenbusStateClosing);
+	xenbus_switch_state_hvm(dev, XenbusStateClosing);
 	timeout = wait_for_completion_timeout(&dev->down, timeout);
 	if (!timeout)
 		printk(KERN_INFO "%s: %s timeout closing device\n",
@@ -287,9 +307,9 @@
  out:
 	put_device(&dev->dev);
 }
-EXPORT_SYMBOL_GPL(xenbus_dev_shutdown);
+EXPORT_SYMBOL_GPL(xenbus_dev_shutdown_hvm);
 
-int xenbus_register_driver_common(struct xenbus_driver *drv,
+int xenbus_register_driver_common_hvm(struct xenbus_driver *drv,
 				  struct xen_bus_type *bus,
 				  struct module *owner,
 				  const char *mod_name)
@@ -301,13 +321,13 @@
 
 	return driver_register(&drv->driver);
 }
-EXPORT_SYMBOL_GPL(xenbus_register_driver_common);
+EXPORT_SYMBOL_GPL(xenbus_register_driver_common_hvm);
 
-void xenbus_unregister_driver(struct xenbus_driver *drv)
+void xenbus_unregister_driver_hvm(struct xenbus_driver *drv)
 {
 	driver_unregister(&drv->driver);
 }
-EXPORT_SYMBOL_GPL(xenbus_unregister_driver);
+EXPORT_SYMBOL_GPL(xenbus_unregister_driver_hvm);
 
 struct xb_find_info
 {
@@ -328,7 +348,7 @@
 	return 0;
 }
 
-struct xenbus_device *xenbus_device_find(const char *nodename,
+struct xenbus_device *xenbus_device_find_hvm(const char *nodename,
 					 struct bus_type *bus)
 {
 	struct xb_find_info info = { .dev = NULL, .nodename = nodename };
@@ -361,11 +381,11 @@
 static void xenbus_cleanup_devices(const char *path, struct bus_type *bus)
 {
 	struct xb_find_info info = { .nodename = path };
-
 	do {
 		info.dev = NULL;
 		bus_for_each_dev(bus, NULL, &info, cleanup_dev);
 		if (info.dev) {
+			printk("XENBLANKET-DOM0: unregister dev.\n");
 			device_unregister(&info.dev->dev);
 			put_device(&info.dev->dev);
 		}
@@ -397,15 +417,15 @@
 		       to_xenbus_device(dev)->devicetype);
 }
 
-struct device_attribute xenbus_dev_attrs[] = {
+struct device_attribute xenbus_dev_attrs_hvm[] = {
 	__ATTR_RO(nodename),
 	__ATTR_RO(devtype),
 	__ATTR_RO(modalias),
 	__ATTR_NULL
 };
-EXPORT_SYMBOL_GPL(xenbus_dev_attrs);
+EXPORT_SYMBOL_GPL(xenbus_dev_attrs_hvm);
 
-int xenbus_probe_node(struct xen_bus_type *bus,
+int xenbus_probe_node_hvm(struct xen_bus_type *bus,
 		      const char *type,
 		      const char *nodename)
 {
@@ -415,7 +435,8 @@
 	size_t stringlen;
 	char *tmpstring;
 
-	enum xenbus_state state = xenbus_read_driver_state(nodename);
+	enum xenbus_state state = xenbus_read_driver_state_hvm(nodename);
+
 
 	if (state != XenbusStateInitialising) {
 		/* Device is not new, so ignore it.  This can happen if a
@@ -460,7 +481,7 @@
 	kfree(xendev);
 	return err;
 }
-EXPORT_SYMBOL_GPL(xenbus_probe_node);
+EXPORT_SYMBOL_GPL(xenbus_probe_node_hvm);
 
 static int xenbus_probe_device_type(struct xen_bus_type *bus, const char *type)
 {
@@ -469,7 +490,7 @@
 	unsigned int dir_n = 0;
 	int i;
 
-	dir = xenbus_directory(XBT_NIL, bus->root, type, &dir_n);
+	dir = xenbus_directory_hvm(XBT_NIL, bus->root, type, &dir_n);
 	if (IS_ERR(dir))
 		return PTR_ERR(dir);
 
@@ -478,20 +499,20 @@
 		if (err)
 			break;
 	}
-
 	kfree(dir);
 	return err;
 }
 
-int xenbus_probe_devices(struct xen_bus_type *bus)
+int xenbus_probe_devices_hvm(struct xen_bus_type *bus)
 {
 	int err = 0;
 	char **dir;
 	unsigned int i, dir_n;
 
-	dir = xenbus_directory(XBT_NIL, bus->root, "", &dir_n);
-	if (IS_ERR(dir))
+	dir = xenbus_directory_hvm(XBT_NIL, bus->root, "", &dir_n);
+	if (IS_ERR(dir)) {
 		return PTR_ERR(dir);
+	}
 
 	for (i = 0; i < dir_n; i++) {
 		err = xenbus_probe_device_type(bus, dir[i]);
@@ -502,7 +523,7 @@
 	kfree(dir);
 	return err;
 }
-EXPORT_SYMBOL_GPL(xenbus_probe_devices);
+EXPORT_SYMBOL_GPL(xenbus_probe_devices_hvm);
 
 static unsigned int char_count(const char *str, char c)
 {
@@ -527,7 +548,7 @@
 	return (len == 0) ? i : -ERANGE;
 }
 
-void xenbus_dev_changed(const char *node, struct xen_bus_type *bus)
+void xenbus_dev_changed_hvm(const char *node, struct xen_bus_type *bus)
 {
 	int exists, rootlen;
 	struct xenbus_device *dev;
@@ -537,7 +558,7 @@
 	if (char_count(node, '/') < 2)
 		return;
 
-	exists = xenbus_exists(XBT_NIL, node, "");
+	exists = xenbus_exists_hvm(XBT_NIL, node, "");
 	if (!exists) {
 		xenbus_cleanup_devices(node, &bus->bus);
 		return;
@@ -555,17 +576,17 @@
 	if (!root)
 		return;
 
-	dev = xenbus_device_find(root, &bus->bus);
+	dev = xenbus_device_find_hvm(root, &bus->bus);
 	if (!dev)
-		xenbus_probe_node(bus, type, root);
+		xenbus_probe_node_hvm(bus, type, root);
 	else
 		put_device(&dev->dev);
 
 	kfree(root);
 }
-EXPORT_SYMBOL_GPL(xenbus_dev_changed);
+EXPORT_SYMBOL_GPL(xenbus_dev_changed_hvm);
 
-int xenbus_dev_suspend(struct device *dev)
+int xenbus_dev_suspend_hvm(struct device *dev)
 {
 	int err = 0;
 	struct xenbus_driver *drv;
@@ -584,9 +605,9 @@
 		       "xenbus: suspend %s failed: %i\n", dev_name(dev), err);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(xenbus_dev_suspend);
+EXPORT_SYMBOL_GPL(xenbus_dev_suspend_hvm);
 
-int xenbus_dev_resume(struct device *dev)
+int xenbus_dev_resume_hvm(struct device *dev)
 {
 	int err;
 	struct xenbus_driver *drv;
@@ -628,63 +649,48 @@
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(xenbus_dev_resume);
+EXPORT_SYMBOL_GPL(xenbus_dev_resume_hvm);
 
-int xenbus_dev_cancel(struct device *dev)
+int xenbus_dev_cancel_hvm(struct device *dev)
 {
 	/* Do nothing */
 	DPRINTK("cancel");
 	return 0;
 }
-EXPORT_SYMBOL_GPL(xenbus_dev_cancel);
+EXPORT_SYMBOL_GPL(xenbus_dev_cancel_hvm);
 
 /* A flag to determine if xenstored is 'ready' (i.e. has started) */
-int xenstored_ready = 0;
+int xenstored_ready_hvm = 0;
 
 
-int register_xenstore_notifier(struct notifier_block *nb)
+int register_xenstore_notifier_hvm(struct notifier_block *nb)
 {
 	int ret = 0;
 
-	if (xenstored_ready > 0)
+	if (xenstored_ready_hvm > 0)
 		ret = nb->notifier_call(nb, 0, NULL);
 	else
 		blocking_notifier_chain_register(&xenstore_chain, nb);
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(register_xenstore_notifier);
+EXPORT_SYMBOL_GPL(register_xenstore_notifier_hvm);
 
-void unregister_xenstore_notifier(struct notifier_block *nb)
+void unregister_xenstore_notifier_hvm(struct notifier_block *nb)
 {
 	blocking_notifier_chain_unregister(&xenstore_chain, nb);
 }
-EXPORT_SYMBOL_GPL(unregister_xenstore_notifier);
+EXPORT_SYMBOL_GPL(unregister_xenstore_notifier_hvm);
 
-void xenbus_probe(struct work_struct *unused)
+void xenbus_probe_hvm(struct work_struct *unused)
 {
-	xenstored_ready = 1;
-
+	xenstored_ready_hvm = 1;
 	/* Notify others that xenstore is up */
 	blocking_notifier_call_chain(&xenstore_chain, 0, NULL);
 }
-EXPORT_SYMBOL_GPL(xenbus_probe);
-
-static int __init xenbus_probe_initcall(void)
-{
-	if (!xen_domain())
-		return -ENODEV;
-
-	if (xen_initial_domain() || xen_hvm_domain())
-		return 0;
-
-	xenbus_probe(NULL);
-	return 0;
-}
-
-device_initcall(xenbus_probe_initcall);
+EXPORT_SYMBOL_GPL(xenbus_probe_hvm);
 
-static int __init xenbus_init(void)
+int __init xenbus_init_hvm(void)
 {
 	int err = 0;
 	unsigned long page = 0;
@@ -698,54 +704,23 @@
 	/*
 	 * Domain0 doesn't have a store_evtchn or store_mfn yet.
 	 */
-	if (xen_initial_domain()) {
-		struct evtchn_alloc_unbound alloc_unbound;
-
-		/* Allocate Xenstore page */
-		page = get_zeroed_page(GFP_KERNEL);
-		if (!page)
+	if (xenblanket_platform) {
+		uint64_t v = 0;
+		err = hvm_get_parameter_hvm(HVM_PARAM_STORE_EVTCHN, &v);
+		if (err)
 			goto out_error;
-
-		xen_store_mfn = xen_start_info->store_mfn =
-			pfn_to_mfn(virt_to_phys((void *)page) >>
-				   PAGE_SHIFT);
-
-		/* Next allocate a local port which xenstored can bind to */
-		alloc_unbound.dom        = DOMID_SELF;
-		alloc_unbound.remote_dom = 0;
-
-		err = HYPERVISOR_event_channel_op(EVTCHNOP_alloc_unbound,
-						  &alloc_unbound);
-		if (err == -ENOSYS)
+		xen_store_evtchn_hvm = (int)v;
+		err = hvm_get_parameter_hvm(HVM_PARAM_STORE_PFN, &v);
+		if (err)
 			goto out_error;
-
-		BUG_ON(err);
-		xen_store_evtchn = xen_start_info->store_evtchn =
-			alloc_unbound.port;
-
-		xen_store_interface = mfn_to_virt(xen_store_mfn);
-	} else {
-		if (xen_hvm_domain()) {
-			uint64_t v = 0;
-			err = hvm_get_parameter(HVM_PARAM_STORE_EVTCHN, &v);
-			if (err)
-				goto out_error;
-			xen_store_evtchn = (int)v;
-			err = hvm_get_parameter(HVM_PARAM_STORE_PFN, &v);
-			if (err)
-				goto out_error;
-			xen_store_mfn = (unsigned long)v;
-			xen_store_interface = ioremap(xen_store_mfn << PAGE_SHIFT, PAGE_SIZE);
-		} else {
-			xen_store_evtchn = xen_start_info->store_evtchn;
-			xen_store_mfn = xen_start_info->store_mfn;
-			xen_store_interface = mfn_to_virt(xen_store_mfn);
-			xenstored_ready = 1;
-		}
+		xen_store_mfn = (unsigned long)v;
+		xen_store_interface_hvm = ioremap(xen_store_mfn << PAGE_SHIFT, PAGE_SIZE);
+		printk("XENBLANKET-DOM0: xenstore evtchn %x xenbus %p.\n",
+		    xen_store_evtchn_hvm, xen_store_interface_hvm);
 	}
 
 	/* Initialize the interface to xenstore. */
-	err = xs_init();
+	err = xs_init_hvm();
 	if (err) {
 		printk(KERN_WARNING
 		       "XENBUS: Error initializing xenstore comms: %i\n", err);
@@ -754,10 +729,11 @@
 
 #ifdef CONFIG_XEN_COMPAT_XENFS
 	/*
+ 	 * Nested Xenbus passthru 	
 	 * Create xenfs mountpoint in /proc for compatibility with
-	 * utilities that expect to find "xenbus" under "/proc/xen".
+	 * utilities that expect to find "xenbus" under "/proc/xen-blanket".
 	 */
-	proc_mkdir("xen", NULL);
+	proc_mkdir("xen-blanket", NULL);
 #endif
 
 	return 0;
@@ -769,6 +745,6 @@
 	return err;
 }
 
-postcore_initcall(xenbus_init);
+//postcore_initcall(xenbus_init_hvm);
 
 MODULE_LICENSE("GPL");
diff -Nur linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_probe.h linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_probe.h
--- linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_probe.h	2012-04-09 05:27:46.638422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_probe.h	2012-03-02 20:28:44.000000000 -0500
@@ -48,33 +48,33 @@
 	struct bus_type bus;
 };
 
-extern struct device_attribute xenbus_dev_attrs[];
+extern struct device_attribute xenbus_dev_attrs_hvm[];
 
-extern int xenbus_match(struct device *_dev, struct device_driver *_drv);
-extern int xenbus_dev_probe(struct device *_dev);
-extern int xenbus_dev_remove(struct device *_dev);
-extern int xenbus_register_driver_common(struct xenbus_driver *drv,
+extern int xenbus_match_hvm(struct device *_dev, struct device_driver *_drv);
+extern int xenbus_dev_probe_hvm(struct device *_dev);
+extern int xenbus_dev_remove_hvm(struct device *_dev);
+extern int xenbus_register_driver_common_hvm(struct xenbus_driver *drv,
 					 struct xen_bus_type *bus,
 					 struct module *owner,
 					 const char *mod_name);
-extern int xenbus_probe_node(struct xen_bus_type *bus,
+extern int xenbus_probe_node_hvm(struct xen_bus_type *bus,
 			     const char *type,
 			     const char *nodename);
-extern int xenbus_probe_devices(struct xen_bus_type *bus);
+extern int xenbus_probe_devices_hvm(struct xen_bus_type *bus);
 
-extern void xenbus_dev_changed(const char *node, struct xen_bus_type *bus);
+extern void xenbus_dev_changed_hvm(const char *node, struct xen_bus_type *bus);
 
-extern void xenbus_dev_shutdown(struct device *_dev);
+extern void xenbus_dev_shutdown_hvm(struct device *_dev);
 
-extern int xenbus_dev_suspend(struct device *dev);
-extern int xenbus_dev_resume(struct device *dev);
-extern int xenbus_dev_cancel(struct device *dev);
+extern int xenbus_dev_suspend_hvm(struct device *dev);
+extern int xenbus_dev_resume_hvm(struct device *dev);
+extern int xenbus_dev_cancel_hvm(struct device *dev);
 
-extern void xenbus_otherend_changed(struct xenbus_watch *watch,
+extern void xenbus_otherend_changed_hvm(struct xenbus_watch *watch,
 				    const char **vec, unsigned int len,
 				    int ignore_on_shutdown);
 
-extern int xenbus_read_otherend_details(struct xenbus_device *xendev,
+extern int xenbus_read_otherend_details_hvm(struct xenbus_device *xendev,
 					char *id_node, char *path_node);
 
 #endif
diff -Nur linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_probe_backend.c linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_probe_backend.c
--- linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_probe_backend.c	2012-04-09 05:27:46.638422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_probe_backend.c	2012-03-02 20:28:44.000000000 -0500
@@ -47,8 +47,8 @@
 #include <asm/pgtable.h>
 #include <asm/xen/hypervisor.h>
 #include <asm/hypervisor.h>
-#include <xen/xenbus.h>
-#include <xen/features.h>
+#include "xenbus.h"
+#include "../features.h"
 
 #include "xenbus_comms.h"
 #include "xenbus_probe.h"
@@ -70,14 +70,14 @@
 
 	devid = strrchr(nodename, '/') + 1;
 
-	err = xenbus_gather(XBT_NIL, nodename, "frontend-id", "%i", &domid,
+	err = xenbus_gather_hvm(XBT_NIL, nodename, "frontend-id", "%i", &domid,
 			    "frontend", NULL, &frontend,
 			    NULL);
 	if (err)
 		return err;
 	if (strlen(frontend) == 0)
 		err = -ERANGE;
-	if (!err && !xenbus_exists(XBT_NIL, frontend, ""))
+	if (!err && !xenbus_exists_hvm(XBT_NIL, frontend, ""))
 		err = -ENOENT;
 	kfree(frontend);
 
@@ -144,7 +144,7 @@
 
 	DPRINTK("%s\n", nodename);
 
-	err = xenbus_probe_node(bus, type, nodename);
+	err = xenbus_probe_node_hvm(bus, type, nodename);
 	kfree(nodename);
 	return err;
 }
@@ -164,7 +164,7 @@
 	if (!nodename)
 		return -ENOMEM;
 
-	dir = xenbus_directory(XBT_NIL, nodename, "", &dir_n);
+	dir = xenbus_directory_hvm(XBT_NIL, nodename, "", &dir_n);
 	if (IS_ERR(dir)) {
 		kfree(nodename);
 		return PTR_ERR(dir);
@@ -183,7 +183,7 @@
 static void frontend_changed(struct xenbus_watch *watch,
 			    const char **vec, unsigned int len)
 {
-	xenbus_otherend_changed(watch, vec, len, 0);
+	xenbus_otherend_changed_hvm(watch, vec, len, 0);
 }
 
 static struct xen_bus_type xenbus_backend = {
@@ -193,13 +193,13 @@
 	.probe = xenbus_probe_backend,
 	.otherend_changed = frontend_changed,
 	.bus = {
-		.name		= "xen-backend",
-		.match		= xenbus_match,
+		.name		= "xenblanket-backend",
+		.match		= xenbus_match_hvm,
 		.uevent		= xenbus_uevent_backend,
-		.probe		= xenbus_dev_probe,
-		.remove		= xenbus_dev_remove,
-		.shutdown	= xenbus_dev_shutdown,
-		.dev_attrs	= xenbus_dev_attrs,
+		.probe		= xenbus_dev_probe_hvm,
+		.remove		= xenbus_dev_remove_hvm,
+		.shutdown	= xenbus_dev_shutdown_hvm,
+		.dev_attrs	= xenbus_dev_attrs_hvm,
 	},
 };
 
@@ -208,7 +208,7 @@
 {
 	DPRINTK("");
 
-	xenbus_dev_changed(vec[XS_WATCH_PATH], &xenbus_backend);
+	xenbus_dev_changed_hvm(vec[XS_WATCH_PATH], &xenbus_backend);
 }
 
 static struct xenbus_watch be_watch = {
@@ -218,43 +218,45 @@
 
 static int read_frontend_details(struct xenbus_device *xendev)
 {
-	return xenbus_read_otherend_details(xendev, "frontend-id", "frontend");
+	return xenbus_read_otherend_details_hvm(xendev, "frontend-id", "frontend");
 }
 
-int xenbus_dev_is_online(struct xenbus_device *dev)
+int xenbus_dev_is_online_hvm(struct xenbus_device *dev)
 {
 	int rc, val;
 
-	rc = xenbus_scanf(XBT_NIL, dev->nodename, "online", "%d", &val);
+	printk("XENBLANKET-DOM0: xenbus_dev_is_online_hvm %p %p.\n", dev, dev->nodename);
+
+	rc = xenbus_scanf_hvm(XBT_NIL, dev->nodename, "online", "%d", &val);
 	if (rc != 1)
 		val = 0; /* no online node present */
 
 	return val;
 }
-EXPORT_SYMBOL_GPL(xenbus_dev_is_online);
+EXPORT_SYMBOL_GPL(xenbus_dev_is_online_hvm);
 
-int __xenbus_register_backend(struct xenbus_driver *drv,
+int __xenbus_register_backend_hvm(struct xenbus_driver *drv,
 			      struct module *owner, const char *mod_name)
 {
 	drv->read_otherend_details = read_frontend_details;
 
-	return xenbus_register_driver_common(drv, &xenbus_backend,
+	return xenbus_register_driver_common_hvm(drv, &xenbus_backend,
 					     owner, mod_name);
 }
-EXPORT_SYMBOL_GPL(__xenbus_register_backend);
+EXPORT_SYMBOL_GPL(__xenbus_register_backend_hvm);
 
 static int backend_probe_and_watch(struct notifier_block *notifier,
 				   unsigned long event,
 				   void *data)
 {
 	/* Enumerate devices in xenstore and watch for changes. */
-	xenbus_probe_devices(&xenbus_backend);
-	register_xenbus_watch(&be_watch);
+	xenbus_probe_devices_hvm(&xenbus_backend);
+	register_xenbus_watch_hvm(&be_watch);
 
 	return NOTIFY_DONE;
 }
 
-static int __init xenbus_probe_backend_init(void)
+int __init xenbus_probe_backend_init_hvm(void)
 {
 	static struct notifier_block xenstore_notifier = {
 		.notifier_call = backend_probe_and_watch
@@ -262,14 +264,16 @@
 	int err;
 
 	DPRINTK("");
+        printk("XENBLANKET-DOM0: xenbus_probe_backend_init().\n");
 
 	/* Register ourselves with the kernel bus subsystem */
 	err = bus_register(&xenbus_backend.bus);
 	if (err)
 		return err;
 
-	register_xenstore_notifier(&xenstore_notifier);
+	register_xenstore_notifier_hvm(&xenstore_notifier);
 
 	return 0;
 }
-subsys_initcall(xenbus_probe_backend_init);
+
+//subsys_initcall(xenbus_probe_backend_init_hvm);
diff -Nur linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_probe_frontend.c linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_probe_frontend.c
--- linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_probe_frontend.c	2012-04-09 05:27:46.638422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_probe_frontend.c	2012-04-09 06:38:54.118422003 -0400
@@ -17,8 +17,8 @@
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/xen/hypervisor.h>
-#include <xen/xenbus.h>
-#include <xen/events.h>
+#include "xenbus.h"
+#include "../events.h"
 #include <xen/page.h>
 
 #include <xen/platform_pci.h>
@@ -58,7 +58,7 @@
 
 	DPRINTK("%s", nodename);
 
-	err = xenbus_probe_node(bus, type, nodename);
+	err = xenbus_probe_node_hvm(bus, type, nodename);
 	kfree(nodename);
 	return err;
 }
@@ -78,15 +78,15 @@
 static void backend_changed(struct xenbus_watch *watch,
 			    const char **vec, unsigned int len)
 {
-	xenbus_otherend_changed(watch, vec, len, 1);
+	xenbus_otherend_changed_hvm(watch, vec, len, 1);
 }
 
 static const struct dev_pm_ops xenbus_pm_ops = {
-	.suspend	= xenbus_dev_suspend,
-	.resume		= xenbus_dev_resume,
-	.freeze		= xenbus_dev_suspend,
-	.thaw		= xenbus_dev_cancel,
-	.restore	= xenbus_dev_resume,
+	.suspend	= xenbus_dev_suspend_hvm,
+	.resume		= xenbus_dev_resume_hvm,
+	.freeze		= xenbus_dev_suspend_hvm,
+	.thaw		= xenbus_dev_cancel_hvm,
+	.restore	= xenbus_dev_resume_hvm,
 };
 
 static struct xen_bus_type xenbus_frontend = {
@@ -96,13 +96,13 @@
 	.probe = xenbus_probe_frontend,
 	.otherend_changed = backend_changed,
 	.bus = {
-		.name		= "xen",
-		.match		= xenbus_match,
+		.name		= "xenblanket",
+		.match		= xenbus_match_hvm,
 		.uevent		= xenbus_uevent_frontend,
-		.probe		= xenbus_dev_probe,
-		.remove		= xenbus_dev_remove,
-		.shutdown	= xenbus_dev_shutdown,
-		.dev_attrs	= xenbus_dev_attrs,
+		.probe		= xenbus_dev_probe_hvm,
+		.remove		= xenbus_dev_remove_hvm,
+		.shutdown	= xenbus_dev_shutdown_hvm,
+		.dev_attrs	= xenbus_dev_attrs_hvm,
 
 		.pm		= &xenbus_pm_ops,
 	},
@@ -113,7 +113,7 @@
 {
 	DPRINTK("");
 
-	xenbus_dev_changed(vec[XS_WATCH_PATH], &xenbus_frontend);
+	xenbus_dev_changed_hvm(vec[XS_WATCH_PATH], &xenbus_frontend);
 }
 
 
@@ -125,7 +125,7 @@
 
 static int read_backend_details(struct xenbus_device *xendev)
 {
-	return xenbus_read_otherend_details(xendev, "backend-id", "backend");
+	return xenbus_read_otherend_details_hvm(xendev, "backend-id", "backend");
 }
 
 static int is_device_connecting(struct device *dev, void *data)
@@ -138,6 +138,7 @@
 	 * A device with no driver will never connect. We care only about
 	 * devices which should currently be in the process of connecting.
 	 */
+
 	if (!dev->driver)
 		return 0;
 
@@ -146,6 +147,7 @@
 		return 0;
 
 	xendrv = to_xenbus_driver(dev->driver);
+	printk("XENBLANKET: xendev status: %x.\n", xendev->state);
 	return (xendev->state < XenbusStateConnected ||
 		(xendev->state == XenbusStateConnected &&
 		 xendrv->is_ready && !xendrv->is_ready(xendev)));
@@ -173,7 +175,7 @@
 	} else if (xendev->state < XenbusStateConnected) {
 		enum xenbus_state rstate = XenbusStateUnknown;
 		if (xendev->otherend)
-			rstate = xenbus_read_driver_state(xendev->otherend);
+			rstate = xenbus_read_driver_state_hvm(xendev->otherend);
 		printk(KERN_WARNING "XENBUS: Timeout connecting "
 		       "to device: %s (local state %d, remote state %d)\n",
 		       xendev->nodename, xendev->state, rstate);
@@ -208,7 +210,10 @@
 	if (!ready_to_wait_for_devices || !xen_domain())
 		return;
 
+	printk("XENBLANKET: wait for devices.\n");
+
 	while (exists_connecting_device(drv)) {
+		printk("XENBLANKET: connecting device exists.\n");
 		if (time_after(jiffies, start + (seconds_waited+5)*HZ)) {
 			if (!seconds_waited)
 				printk(KERN_WARNING "XENBUS: Waiting for "
@@ -218,8 +223,7 @@
 			if (seconds_waited == 300)
 				break;
 		}
-
-		schedule_timeout_interruptible(HZ/10);
+		schedule_timeout_interruptible(HZ);
 	}
 
 	if (seconds_waited)
@@ -229,14 +233,14 @@
 			 print_device_status);
 }
 
-int __xenbus_register_frontend(struct xenbus_driver *drv,
+int __xenbus_register_frontend_hvm(struct xenbus_driver *drv,
 			       struct module *owner, const char *mod_name)
 {
 	int ret;
 
 	drv->read_otherend_details = read_backend_details;
 
-	ret = xenbus_register_driver_common(drv, &xenbus_frontend,
+	ret = xenbus_register_driver_common_hvm(drv, &xenbus_frontend,
 					    owner, mod_name);
 	if (ret)
 		return ret;
@@ -246,21 +250,21 @@
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(__xenbus_register_frontend);
+EXPORT_SYMBOL_GPL(__xenbus_register_frontend_hvm);
 
 static int frontend_probe_and_watch(struct notifier_block *notifier,
 				   unsigned long event,
 				   void *data)
 {
 	/* Enumerate devices in xenstore and watch for changes. */
-	xenbus_probe_devices(&xenbus_frontend);
-	register_xenbus_watch(&fe_watch);
 
+	xenbus_probe_devices_hvm(&xenbus_frontend);
+	register_xenbus_watch_hvm(&fe_watch);
 	return NOTIFY_DONE;
 }
 
 
-static int __init xenbus_probe_frontend_init(void)
+int __init xenbus_probe_frontend_init_hvm(void)
 {
 	static struct notifier_block xenstore_notifier = {
 		.notifier_call = frontend_probe_and_watch
@@ -268,22 +272,24 @@
 	int err;
 
 	DPRINTK("");
+        printk("XENBLANKET-DOM0: xenbus_probe_frontend_init().\n");
 
 	/* Register ourselves with the kernel bus subsystem */
 	err = bus_register(&xenbus_frontend.bus);
 	if (err)
 		return err;
 
-	register_xenstore_notifier(&xenstore_notifier);
+	register_xenstore_notifier_hvm(&xenstore_notifier);
 
 	return 0;
 }
-subsys_initcall(xenbus_probe_frontend_init);
+
+//subsys_initcall(xenbus_probe_frontend_init_hvm);
 
 #ifndef MODULE
 static int __init boot_wait_for_devices(void)
 {
-	if (xen_hvm_domain() && !xen_platform_pci_unplug)
+	if (xenblanket_platform && !xen_platform_pci_unplug)
 		return -ENODEV;
 
 	ready_to_wait_for_devices = 1;
diff -Nur linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_xs.c linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_xs.c
--- linux-3.1.2/drivers/xen-blanket/xenbus/xenbus_xs.c	2012-04-09 05:27:46.638422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xenbus/xenbus_xs.c	2012-04-09 06:37:32.614422002 -0400
@@ -44,7 +44,7 @@
 #include <linux/rwsem.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
-#include <xen/xenbus.h>
+#include "xenbus.h"
 #include "xenbus_comms.h"
 
 struct xs_stored_msg {
@@ -192,7 +192,7 @@
 	mutex_unlock(&xs_state.transaction_mutex);
 }
 
-void *xenbus_dev_request_and_reply(struct xsd_sockmsg *msg)
+void *xenbus_dev_request_and_reply_hvm(struct xsd_sockmsg *msg)
 {
 	void *ret;
 	struct xsd_sockmsg req_msg = *msg;
@@ -203,7 +203,7 @@
 
 	mutex_lock(&xs_state.request_mutex);
 
-	err = xb_write(msg, sizeof(*msg) + msg->len);
+	err = xb_write_hvm(msg, sizeof(*msg) + msg->len);
 	if (err) {
 		msg->type = XS_ERROR;
 		ret = ERR_PTR(err);
@@ -219,7 +219,7 @@
 
 	return ret;
 }
-EXPORT_SYMBOL(xenbus_dev_request_and_reply);
+EXPORT_SYMBOL(xenbus_dev_request_and_reply_hvm);
 
 /* Send message to xs, get kmalloc'ed reply.  ERR_PTR() on error. */
 static void *xs_talkv(struct xenbus_transaction t,
@@ -242,14 +242,14 @@
 
 	mutex_lock(&xs_state.request_mutex);
 
-	err = xb_write(&msg, sizeof(msg));
+	err = xb_write_hvm(&msg, sizeof(msg));
 	if (err) {
 		mutex_unlock(&xs_state.request_mutex);
 		return ERR_PTR(err);
 	}
 
 	for (i = 0; i < num_vecs; i++) {
-		err = xb_write(iovec[i].iov_base, iovec[i].iov_len);
+		err = xb_write_hvm(iovec[i].iov_base, iovec[i].iov_len);
 		if (err) {
 			mutex_unlock(&xs_state.request_mutex);
 			return ERR_PTR(err);
@@ -348,7 +348,7 @@
 	return ret;
 }
 
-char **xenbus_directory(struct xenbus_transaction t,
+char **xenbus_directory_hvm(struct xenbus_transaction t,
 			const char *dir, const char *node, unsigned int *num)
 {
 	char *strings, *path;
@@ -365,28 +365,28 @@
 
 	return split(strings, len, num);
 }
-EXPORT_SYMBOL_GPL(xenbus_directory);
+EXPORT_SYMBOL_GPL(xenbus_directory_hvm);
 
 /* Check if a path exists. Return 1 if it does. */
-int xenbus_exists(struct xenbus_transaction t,
+int xenbus_exists_hvm(struct xenbus_transaction t,
 		  const char *dir, const char *node)
 {
 	char **d;
 	int dir_n;
 
-	d = xenbus_directory(t, dir, node, &dir_n);
+	d = xenbus_directory_hvm(t, dir, node, &dir_n);
 	if (IS_ERR(d))
 		return 0;
 	kfree(d);
 	return 1;
 }
-EXPORT_SYMBOL_GPL(xenbus_exists);
+EXPORT_SYMBOL_GPL(xenbus_exists_hvm);
 
 /* Get the value of a single file.
  * Returns a kmalloced value: call free() on it after use.
  * len indicates length in bytes.
  */
-void *xenbus_read(struct xenbus_transaction t,
+void *xenbus_read_hvm(struct xenbus_transaction t,
 		  const char *dir, const char *node, unsigned int *len)
 {
 	char *path;
@@ -400,12 +400,12 @@
 	kfree(path);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(xenbus_read);
+EXPORT_SYMBOL_GPL(xenbus_read_hvm);
 
 /* Write the value of a single file.
  * Returns -err on failure.
  */
-int xenbus_write(struct xenbus_transaction t,
+int xenbus_write_hvm(struct xenbus_transaction t,
 		 const char *dir, const char *node, const char *string)
 {
 	const char *path;
@@ -425,10 +425,10 @@
 	kfree(path);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(xenbus_write);
+EXPORT_SYMBOL_GPL(xenbus_write_hvm);
 
 /* Create a new directory. */
-int xenbus_mkdir(struct xenbus_transaction t,
+int xenbus_mkdir_hvm(struct xenbus_transaction t,
 		 const char *dir, const char *node)
 {
 	char *path;
@@ -442,10 +442,10 @@
 	kfree(path);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(xenbus_mkdir);
+EXPORT_SYMBOL_GPL(xenbus_mkdir_hvm);
 
 /* Destroy a file or directory (directories must be empty). */
-int xenbus_rm(struct xenbus_transaction t, const char *dir, const char *node)
+int xenbus_rm_hvm(struct xenbus_transaction t, const char *dir, const char *node)
 {
 	char *path;
 	int ret;
@@ -458,12 +458,12 @@
 	kfree(path);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(xenbus_rm);
+EXPORT_SYMBOL_GPL(xenbus_rm_hvm);
 
 /* Start a transaction: changes by others will not be seen during this
  * transaction, and changes will not be visible to others until end.
  */
-int xenbus_transaction_start(struct xenbus_transaction *t)
+int xenbus_transaction_start_hvm(struct xenbus_transaction *t)
 {
 	char *id_str;
 
@@ -479,12 +479,12 @@
 	kfree(id_str);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(xenbus_transaction_start);
+EXPORT_SYMBOL_GPL(xenbus_transaction_start_hvm);
 
 /* End a transaction.
  * If abandon is true, transaction is discarded instead of committed.
  */
-int xenbus_transaction_end(struct xenbus_transaction t, int abort)
+int xenbus_transaction_end_hvm(struct xenbus_transaction t, int abort)
 {
 	char abortstr[2];
 	int err;
@@ -500,17 +500,17 @@
 
 	return err;
 }
-EXPORT_SYMBOL_GPL(xenbus_transaction_end);
+EXPORT_SYMBOL_GPL(xenbus_transaction_end_hvm);
 
 /* Single read and scanf: returns -errno or num scanned. */
-int xenbus_scanf(struct xenbus_transaction t,
+int xenbus_scanf_hvm(struct xenbus_transaction t,
 		 const char *dir, const char *node, const char *fmt, ...)
 {
 	va_list ap;
 	int ret;
 	char *val;
 
-	val = xenbus_read(t, dir, node, NULL);
+	val = xenbus_read_hvm(t, dir, node, NULL);
 	if (IS_ERR(val))
 		return PTR_ERR(val);
 
@@ -523,10 +523,10 @@
 		return -ERANGE;
 	return ret;
 }
-EXPORT_SYMBOL_GPL(xenbus_scanf);
+EXPORT_SYMBOL_GPL(xenbus_scanf_hvm);
 
 /* Single printf and write: returns -errno or 0. */
-int xenbus_printf(struct xenbus_transaction t,
+int xenbus_printf_hvm(struct xenbus_transaction t,
 		  const char *dir, const char *node, const char *fmt, ...)
 {
 	va_list ap;
@@ -543,16 +543,16 @@
 	va_end(ap);
 
 	BUG_ON(ret > PRINTF_BUFFER_SIZE-1);
-	ret = xenbus_write(t, dir, node, printf_buffer);
+	ret = xenbus_write_hvm(t, dir, node, printf_buffer);
 
 	kfree(printf_buffer);
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(xenbus_printf);
+EXPORT_SYMBOL_GPL(xenbus_printf_hvm);
 
 /* Takes tuples of names, scanf-style args, and void **, NULL terminated. */
-int xenbus_gather(struct xenbus_transaction t, const char *dir, ...)
+int xenbus_gather_hvm(struct xenbus_transaction t, const char *dir, ...)
 {
 	va_list ap;
 	const char *name;
@@ -564,7 +564,7 @@
 		void *result = va_arg(ap, void *);
 		char *p;
 
-		p = xenbus_read(t, dir, name, NULL);
+		p = xenbus_read_hvm(t, dir, name, NULL);
 		if (IS_ERR(p)) {
 			ret = PTR_ERR(p);
 			break;
@@ -579,7 +579,7 @@
 	va_end(ap);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(xenbus_gather);
+EXPORT_SYMBOL_GPL(xenbus_gather_hvm);
 
 static int xs_watch(const char *path, const char *token)
 {
@@ -621,7 +621,7 @@
 }
 
 /* Register callback to watch this node. */
-int register_xenbus_watch(struct xenbus_watch *watch)
+int register_xenbus_watch_hvm(struct xenbus_watch *watch)
 {
 	/* Pointer in ascii is the token. */
 	char token[sizeof(watch) * 2 + 1];
@@ -649,9 +649,9 @@
 
 	return err;
 }
-EXPORT_SYMBOL_GPL(register_xenbus_watch);
+EXPORT_SYMBOL_GPL(register_xenbus_watch_hvm);
 
-void unregister_xenbus_watch(struct xenbus_watch *watch)
+void unregister_xenbus_watch_hvm(struct xenbus_watch *watch)
 {
 	struct xs_stored_msg *msg, *tmp;
 	char token[sizeof(watch) * 2 + 1];
@@ -693,9 +693,9 @@
 	if (current->pid != xenwatch_pid)
 		mutex_unlock(&xenwatch_mutex);
 }
-EXPORT_SYMBOL_GPL(unregister_xenbus_watch);
+EXPORT_SYMBOL_GPL(unregister_xenbus_watch_hvm);
 
-void xs_suspend(void)
+void xs_suspend_hvm(void)
 {
 	transaction_suspend();
 	down_write(&xs_state.watch_mutex);
@@ -703,12 +703,12 @@
 	mutex_lock(&xs_state.response_mutex);
 }
 
-void xs_resume(void)
+void xs_resume_hvm(void)
 {
 	struct xenbus_watch *watch;
 	char token[sizeof(watch) * 2 + 1];
 
-	xb_init_comms();
+	xb_init_comms_hvm();
 
 	mutex_unlock(&xs_state.response_mutex);
 	mutex_unlock(&xs_state.request_mutex);
@@ -723,7 +723,7 @@
 	up_write(&xs_state.watch_mutex);
 }
 
-void xs_suspend_cancel(void)
+void xs_suspend_cancel_hvm(void)
 {
 	mutex_unlock(&xs_state.response_mutex);
 	mutex_unlock(&xs_state.request_mutex);
@@ -778,11 +778,11 @@
 	 * A partial read across s/r leaves us out of sync with xenstored.
 	 */
 	for (;;) {
-		err = xb_wait_for_data_to_read();
+		err = xb_wait_for_data_to_read_hvm();
 		if (err)
 			return err;
 		mutex_lock(&xs_state.response_mutex);
-		if (xb_data_to_read())
+		if (xb_data_to_read_hvm())
 			break;
 		/* We raced with save/restore: pending data 'disappeared'. */
 		mutex_unlock(&xs_state.response_mutex);
@@ -795,7 +795,7 @@
 		goto out;
 	}
 
-	err = xb_read(&msg->hdr, sizeof(msg->hdr));
+	err = xb_read_hvm(&msg->hdr, sizeof(msg->hdr));
 	if (err) {
 		kfree(msg);
 		goto out;
@@ -808,7 +808,7 @@
 		goto out;
 	}
 
-	err = xb_read(body, msg->hdr.len);
+	err = xb_read_hvm(body, msg->hdr.len);
 	if (err) {
 		kfree(body);
 		kfree(msg);
@@ -867,7 +867,7 @@
 	return 0;
 }
 
-int xs_init(void)
+int xs_init_hvm(void)
 {
 	int err;
 	struct task_struct *task;
@@ -884,16 +884,16 @@
 	init_waitqueue_head(&xs_state.transaction_wq);
 
 	/* Initialize the shared memory rings to talk to xenstored */
-	err = xb_init_comms();
+	err = xb_init_comms_hvm();
 	if (err)
 		return err;
 
-	task = kthread_run(xenwatch_thread, NULL, "xenwatch");
+	task = kthread_run(xenwatch_thread, NULL, "xenblanket_xenwatch");
 	if (IS_ERR(task))
 		return PTR_ERR(task);
 	xenwatch_pid = task->pid;
 
-	task = kthread_run(xenbus_thread, NULL, "xenbus");
+	task = kthread_run(xenbus_thread, NULL, "xenblanet_xenbus");
 	if (IS_ERR(task))
 		return PTR_ERR(task);
 
diff -Nur linux-3.1.2/drivers/xen-blanket/xendev/Makefile linux-3.1.2-xenblanket/drivers/xen-blanket/xendev/Makefile
--- linux-3.1.2/drivers/xen-blanket/xendev/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xendev/Makefile	2012-03-02 20:28:44.000000000 -0500
@@ -0,0 +1,2 @@
+obj-y   += xen-blkfront.o
+obj-y 	+= xen-netfront.o
diff -Nur linux-3.1.2/drivers/xen-blanket/xendev/xen-blkfront.c linux-3.1.2-xenblanket/drivers/xen-blanket/xendev/xen-blkfront.c
--- linux-3.1.2/drivers/xen-blanket/xendev/xen-blkfront.c	2012-04-09 05:27:46.652422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xendev/xen-blkfront.c	2012-04-09 06:41:00.155422003 -0400
@@ -45,18 +45,22 @@
 #include <linux/scatterlist.h>
 
 #include <xen/xen.h>
-#include <xen/xenbus.h>
-#include <xen/grant_table.h>
-#include <xen/events.h>
+#include "../xenbus/xenbus.h"
+#include "../grant_table.h"
+#include "../events.h"
 #include <xen/page.h>
 #include <xen/platform_pci.h>
 
-#include <xen/interface/grant_table.h>
 #include <xen/interface/io/blkif.h>
 #include <xen/interface/io/protocols.h>
 
 #include <asm/xen/hypervisor.h>
 
+extern int bind_evtchn_to_irqhandler_hvm(unsigned int evtchn,
+                              irq_handler_t handler,
+                              unsigned long irqflags, const char *devname,
+                              void *dev_id);
+
 enum blkif_state {
 	BLKIF_STATE_DISCONNECTED,
 	BLKIF_STATE_CONNECTED,
@@ -123,8 +127,8 @@
 #define BLKIF_MINOR_EXT(dev) ((dev)&(~EXTENDED))
 #define EMULATED_HD_DISK_MINOR_OFFSET (0)
 #define EMULATED_HD_DISK_NAME_OFFSET (EMULATED_HD_DISK_MINOR_OFFSET / 256)
-#define EMULATED_SD_DISK_MINOR_OFFSET (0)
-#define EMULATED_SD_DISK_NAME_OFFSET (EMULATED_SD_DISK_MINOR_OFFSET / 256)
+#define EMULATED_SD_DISK_MINOR_OFFSET (EMULATED_HD_DISK_MINOR_OFFSET + (4 * 16))
+#define EMULATED_SD_DISK_NAME_OFFSET (EMULATED_HD_DISK_NAME_OFFSET + 4)
 
 #define DEV_NAME	"xvd"	/* name in /dev */
 
@@ -269,9 +273,9 @@
 	if (unlikely(info->connected != BLKIF_STATE_CONNECTED))
 		return 1;
 
-	if (gnttab_alloc_grant_references(
+	if (gnttab_alloc_grant_references_hvm(
 		BLKIF_MAX_SEGMENTS_PER_REQUEST, &gref_head) < 0) {
-		gnttab_request_free_callback(
+		gnttab_request_free_callback_hvm(
 			&info->callback,
 			blkif_restart_queue_callback,
 			info,
@@ -310,10 +314,10 @@
 		fsect = sg->offset >> 9;
 		lsect = fsect + (sg->length >> 9) - 1;
 		/* install a grant reference. */
-		ref = gnttab_claim_grant_reference(&gref_head);
+		ref = gnttab_claim_grant_reference_hvm(&gref_head);
 		BUG_ON(ref == -ENOSPC);
 
-		gnttab_grant_foreign_access_ref(
+		gnttab_grant_foreign_access_ref_hvm(
 				ref,
 				info->xbdev->otherend_id,
 				buffer_mfn,
@@ -332,7 +336,7 @@
 	/* Keep a private copy so we can reissue requests when recovering. */
 	info->shadow[id].req = *ring_req;
 
-	gnttab_free_grant_references(gref_head);
+	gnttab_free_grant_references_hvm(gref_head);
 
 	return 0;
 }
@@ -345,7 +349,7 @@
 	RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&info->ring, notify);
 
 	if (notify)
-		notify_remote_via_irq(info->irq);
+		notify_remote_via_irq_hvm(info->irq);
 }
 
 /*
@@ -529,7 +533,7 @@
 		minor = BLKIF_MINOR_EXT(info->vdevice);
 		nr_parts = PARTS_PER_EXT_DISK;
 		offset = minor / nr_parts;
-		if (xen_hvm_domain() && offset < EMULATED_HD_DISK_NAME_OFFSET + 4)
+		if (xen_hvm_domain() && offset <= EMULATED_HD_DISK_NAME_OFFSET + 4)
 			printk(KERN_WARNING "blkfront: vdevice 0x%x might conflict with "
 					"emulated IDE disks,\n\t choose an xvd device name"
 					"from xvde on\n", info->vdevice);
@@ -614,7 +618,7 @@
 	blk_stop_queue(info->rq);
 
 	/* No more gnttab callback work. */
-	gnttab_cancel_free_callback(&info->callback);
+	gnttab_cancel_free_callback_hvm(&info->callback);
 	spin_unlock_irqrestore(&blkif_io_lock, flags);
 
 	/* Flush gnttab callback work. Must be done with no locks held. */
@@ -663,7 +667,7 @@
 	if (info->rq)
 		blk_stop_queue(info->rq);
 	/* No more gnttab callback work. */
-	gnttab_cancel_free_callback(&info->callback);
+	gnttab_cancel_free_callback_hvm(&info->callback);
 	spin_unlock_irq(&blkif_io_lock);
 
 	/* Flush gnttab callback work. Must be done with no locks held. */
@@ -671,13 +675,13 @@
 
 	/* Free resources associated with old device channel. */
 	if (info->ring_ref != GRANT_INVALID_REF) {
-		gnttab_end_foreign_access(info->ring_ref, 0,
+		gnttab_end_foreign_access_hvm(info->ring_ref, 0,
 					  (unsigned long)info->ring.sring);
 		info->ring_ref = GRANT_INVALID_REF;
 		info->ring.sring = NULL;
 	}
 	if (info->irq)
-		unbind_from_irqhandler(info->irq, info);
+		unbind_from_irqhandler_hvm(info->irq, info);
 	info->evtchn = info->irq = 0;
 
 }
@@ -686,7 +690,7 @@
 {
 	int i;
 	for (i = 0; i < s->req.nr_segments; i++)
-		gnttab_end_foreign_access(s->req.u.rw.seg[i].gref, 0, 0UL);
+		gnttab_end_foreign_access_hvm(s->req.u.rw.seg[i].gref, 0, 0UL);
 }
 
 static irqreturn_t blkif_interrupt(int irq, void *dev_id)
@@ -788,7 +792,7 @@
 
 	sring = (struct blkif_sring *)__get_free_page(GFP_NOIO | __GFP_HIGH);
 	if (!sring) {
-		xenbus_dev_fatal(dev, -ENOMEM, "allocating shared ring");
+		xenbus_dev_fatal_hvm(dev, -ENOMEM, "allocating shared ring");
 		return -ENOMEM;
 	}
 	SHARED_RING_INIT(sring);
@@ -796,7 +800,7 @@
 
 	sg_init_table(info->sg, BLKIF_MAX_SEGMENTS_PER_REQUEST);
 
-	err = xenbus_grant_ring(dev, virt_to_mfn(info->ring.sring));
+	err = xenbus_grant_ring_hvm(dev, virt_to_mfn(info->ring.sring));
 	if (err < 0) {
 		free_page((unsigned long)sring);
 		info->ring.sring = NULL;
@@ -804,15 +808,15 @@
 	}
 	info->ring_ref = err;
 
-	err = xenbus_alloc_evtchn(dev, &info->evtchn);
+	err = xenbus_alloc_evtchn_hvm(dev, &info->evtchn);
 	if (err)
 		goto fail;
 
-	err = bind_evtchn_to_irqhandler(info->evtchn,
+	err = bind_evtchn_to_irqhandler_hvm(info->evtchn,
 					blkif_interrupt,
 					IRQF_SAMPLE_RANDOM, "blkif", info);
 	if (err <= 0) {
-		xenbus_dev_fatal(dev, err,
+		xenbus_dev_fatal_hvm(dev, err,
 				 "bind_evtchn_to_irqhandler failed");
 		goto fail;
 	}
@@ -839,47 +843,47 @@
 		goto out;
 
 again:
-	err = xenbus_transaction_start(&xbt);
+	err = xenbus_transaction_start_hvm(&xbt);
 	if (err) {
-		xenbus_dev_fatal(dev, err, "starting transaction");
+		xenbus_dev_fatal_hvm(dev, err, "starting transaction");
 		goto destroy_blkring;
 	}
 
-	err = xenbus_printf(xbt, dev->nodename,
+	err = xenbus_printf_hvm(xbt, dev->nodename,
 			    "ring-ref", "%u", info->ring_ref);
 	if (err) {
 		message = "writing ring-ref";
 		goto abort_transaction;
 	}
-	err = xenbus_printf(xbt, dev->nodename,
+	err = xenbus_printf_hvm(xbt, dev->nodename,
 			    "event-channel", "%u", info->evtchn);
 	if (err) {
 		message = "writing event-channel";
 		goto abort_transaction;
 	}
-	err = xenbus_printf(xbt, dev->nodename, "protocol", "%s",
+	err = xenbus_printf_hvm(xbt, dev->nodename, "protocol", "%s",
 			    XEN_IO_PROTO_ABI_NATIVE);
 	if (err) {
 		message = "writing protocol";
 		goto abort_transaction;
 	}
 
-	err = xenbus_transaction_end(xbt, 0);
+	err = xenbus_transaction_end_hvm(xbt, 0);
 	if (err) {
 		if (err == -EAGAIN)
 			goto again;
-		xenbus_dev_fatal(dev, err, "completing transaction");
+		xenbus_dev_fatal_hvm(dev, err, "completing transaction");
 		goto destroy_blkring;
 	}
 
-	xenbus_switch_state(dev, XenbusStateInitialised);
+	xenbus_switch_state_hvm(dev, XenbusStateInitialised);
 
 	return 0;
 
  abort_transaction:
-	xenbus_transaction_end(xbt, 1);
+	xenbus_transaction_end_hvm(xbt, 1);
 	if (message)
-		xenbus_dev_fatal(dev, err, "%s", message);
+		xenbus_dev_fatal_hvm(dev, err, "%s", message);
  destroy_blkring:
 	blkif_free(info, 0);
  out:
@@ -899,14 +903,14 @@
 	struct blkfront_info *info;
 
 	/* FIXME: Use dynamic device id if this is not set. */
-	err = xenbus_scanf(XBT_NIL, dev->nodename,
+	err = xenbus_scanf_hvm(XBT_NIL, dev->nodename,
 			   "virtual-device", "%i", &vdevice);
 	if (err != 1) {
 		/* go looking in the extended area instead */
-		err = xenbus_scanf(XBT_NIL, dev->nodename, "virtual-device-ext",
+		err = xenbus_scanf_hvm(XBT_NIL, dev->nodename, "virtual-device-ext",
 				   "%i", &vdevice);
 		if (err != 1) {
-			xenbus_dev_fatal(dev, err, "reading virtual-device");
+			xenbus_dev_fatal_hvm(dev, err, "reading virtual-device");
 			return err;
 		}
 	}
@@ -931,7 +935,7 @@
 			}
 		}
 		/* do not create a PV cdrom device if we are an HVM guest */
-		type = xenbus_read(XBT_NIL, dev->nodename, "device-type", &len);
+		type = xenbus_read_hvm(XBT_NIL, dev->nodename, "device-type", &len);
 		if (IS_ERR(type))
 			return -ENODEV;
 		if (strncmp(type, "cdrom", 5) == 0) {
@@ -942,7 +946,7 @@
 	}
 	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (!info) {
-		xenbus_dev_fatal(dev, -ENOMEM, "allocating info structure");
+		xenbus_dev_fatal_hvm(dev, -ENOMEM, "allocating info structure");
 		return -ENOMEM;
 	}
 
@@ -966,7 +970,7 @@
 		dev_set_drvdata(&dev->dev, NULL);
 		return err;
 	}
-
+	printk("XENBLANKET-VBD: probe done.\n");
 	return 0;
 }
 
@@ -1008,7 +1012,7 @@
 
 		/* Rewrite any grant references invalidated by susp/resume. */
 		for (j = 0; j < req->nr_segments; j++)
-			gnttab_grant_foreign_access_ref(
+			gnttab_grant_foreign_access_ref_hvm(
 				req->u.rw.seg[j].gref,
 				info->xbdev->otherend_id,
 				pfn_to_mfn(info->shadow[req->id].frame[j]),
@@ -1020,7 +1024,7 @@
 
 	kfree(copy);
 
-	xenbus_switch_state(info->xbdev, XenbusStateConnected);
+	xenbus_switch_state_hvm(info->xbdev, XenbusStateConnected);
 
 	spin_lock_irq(&blkif_io_lock);
 
@@ -1079,19 +1083,19 @@
 	mutex_unlock(&info->mutex);
 
 	if (!bdev) {
-		xenbus_frontend_closed(xbdev);
+		xenbus_frontend_closed_hvm(xbdev);
 		return;
 	}
 
 	mutex_lock(&bdev->bd_mutex);
 
 	if (bdev->bd_openers) {
-		xenbus_dev_error(xbdev, -EBUSY,
+		xenbus_dev_error_hvm(xbdev, -EBUSY,
 				 "Device in use; refusing to close");
-		xenbus_switch_state(xbdev, XenbusStateClosing);
+		xenbus_switch_state_hvm(xbdev, XenbusStateClosing);
 	} else {
 		xlvbd_release_gendisk(info);
-		xenbus_frontend_closed(xbdev);
+		xenbus_frontend_closed_hvm(xbdev);
 	}
 
 	mutex_unlock(&bdev->bd_mutex);
@@ -1116,7 +1120,7 @@
 		 * Potentially, the back-end may be signalling
 		 * a capacity change; update the capacity.
 		 */
-		err = xenbus_scanf(XBT_NIL, info->xbdev->otherend,
+		err = xenbus_scanf_hvm(XBT_NIL, info->xbdev->otherend,
 				   "sectors", "%Lu", &sectors);
 		if (XENBUS_EXIST_ERR(err))
 			return;
@@ -1136,13 +1140,13 @@
 	dev_dbg(&info->xbdev->dev, "%s:%s.\n",
 		__func__, info->xbdev->otherend);
 
-	err = xenbus_gather(XBT_NIL, info->xbdev->otherend,
+	err = xenbus_gather_hvm(XBT_NIL, info->xbdev->otherend,
 			    "sectors", "%llu", &sectors,
 			    "info", "%u", &binfo,
 			    "sector-size", "%lu", &sector_size,
 			    NULL);
 	if (err) {
-		xenbus_dev_fatal(info->xbdev, err,
+		xenbus_dev_fatal_hvm(info->xbdev, err,
 				 "reading backend fields at %s",
 				 info->xbdev->otherend);
 		return;
@@ -1151,7 +1155,7 @@
 	info->feature_flush = 0;
 	info->flush_op = 0;
 
-	err = xenbus_gather(XBT_NIL, info->xbdev->otherend,
+	err = xenbus_gather_hvm(XBT_NIL, info->xbdev->otherend,
 			    "feature-barrier", "%d", &barrier,
 			    NULL);
 
@@ -1170,7 +1174,7 @@
 	 * And if there is "feature-flush-cache" use that above
 	 * barriers.
 	 */
-	err = xenbus_gather(XBT_NIL, info->xbdev->otherend,
+	err = xenbus_gather_hvm(XBT_NIL, info->xbdev->otherend,
 			    "feature-flush-cache", "%d", &flush,
 			    NULL);
 
@@ -1181,12 +1185,12 @@
 		
 	err = xlvbd_alloc_gendisk(sectors, info, binfo, sector_size);
 	if (err) {
-		xenbus_dev_fatal(info->xbdev, err, "xlvbd_add at %s",
+		xenbus_dev_fatal_hvm(info->xbdev, err, "xlvbd_add at %s",
 				 info->xbdev->otherend);
 		return;
 	}
 
-	xenbus_switch_state(info->xbdev, XenbusStateConnected);
+	xenbus_switch_state_hvm(info->xbdev, XenbusStateConnected);
 
 	/* Kick pending requests. */
 	spin_lock_irq(&blkif_io_lock);
@@ -1197,6 +1201,8 @@
 	add_disk(info->gd);
 
 	info->is_ready = 1;
+
+	printk("XENBLANKET-VBD: connect done.\n");
 }
 
 /**
@@ -1208,6 +1214,7 @@
 	struct blkfront_info *info = dev_get_drvdata(&dev->dev);
 
 	dev_dbg(&dev->dev, "blkfront:blkback_changed to state %d.\n", backend_state);
+	printk("XENBLANKET-VBD:blkback_changed to state %d.\n", backend_state);
 
 	switch (backend_state) {
 	case XenbusStateInitialising:
@@ -1339,7 +1346,7 @@
 		/* pending switch to state closed */
 		dev_info(disk_to_dev(bdev->bd_disk), "releasing disk\n");
 		xlvbd_release_gendisk(info);
-		xenbus_frontend_closed(info->xbdev);
+		xenbus_frontend_closed_hvm(info->xbdev);
  	}
 
 	mutex_unlock(&info->mutex);
@@ -1373,7 +1380,7 @@
 };
 
 static struct xenbus_driver blkfront = {
-	.name = "vbd",
+	.name = "xenblanket_vbd",
 	.owner = THIS_MODULE,
 	.ids = blkfront_ids,
 	.probe = blkfront_probe,
@@ -1383,30 +1390,37 @@
 	.is_ready = blkfront_is_ready,
 };
 
-static int __init xlblk_init(void)
+int __init xlblk_init_hvm(void)
 {
+	printk("XENBLANKET VBD: init.\n");	
+
 	if (!xen_domain())
 		return -ENODEV;
 
+	if(!xenblanket_platform_initialized)
+		return -ENODEV;
+
 	if (register_blkdev(XENVBD_MAJOR, DEV_NAME)) {
-		printk(KERN_WARNING "xen_blk: can't get major %d with name %s\n",
+		printk(KERN_WARNING "xenblanket_blk: can't get major %d with name %s\n",
 		       XENVBD_MAJOR, DEV_NAME);
 		return -ENODEV;
 	}
 
-	return xenbus_register_frontend(&blkfront);
+	return xenbus_register_frontend_hvm(&blkfront);
 }
-module_init(xlblk_init);
+module_init(xlblk_init_hvm);
+
+EXPORT_SYMBOL_GPL(xlblk_init_hvm);
 
 
 static void __exit xlblk_exit(void)
 {
-	return xenbus_unregister_driver(&blkfront);
+	return xenbus_unregister_driver_hvm(&blkfront);
 }
 module_exit(xlblk_exit);
 
-MODULE_DESCRIPTION("Xen virtual block device frontend");
+MODULE_DESCRIPTION("Xenblanket virtual block device frontend");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_BLOCKDEV_MAJOR(XENVBD_MAJOR);
-MODULE_ALIAS("xen:vbd");
-MODULE_ALIAS("xenblk");
+MODULE_ALIAS("xenblanket:vbd");
+MODULE_ALIAS("xenblanket_xenblk");
diff -Nur linux-3.1.2/drivers/xen-blanket/xendev/xen-netfront.c linux-3.1.2-xenblanket/drivers/xen-blanket/xendev/xen-netfront.c
--- linux-3.1.2/drivers/xen-blanket/xendev/xen-netfront.c	2012-04-09 05:27:46.649422003 -0400
+++ linux-3.1.2-xenblanket/drivers/xen-blanket/xendev/xen-netfront.c	2012-03-02 20:28:45.000000000 -0500
@@ -44,15 +44,18 @@
 #include <net/ip.h>
 
 #include <xen/xen.h>
-#include <xen/xenbus.h>
-#include <xen/events.h>
+#include "../xenbus/xenbus.h"
+#include "../events.h"
 #include <xen/page.h>
-#include <xen/grant_table.h>
+#include "../grant_table.h"
 
 #include <xen/interface/io/netif.h>
 #include <xen/interface/memory.h>
 #include <xen/interface/grant_table.h>
 
+#include "../xenblanket.h"
+#include "../xenblanket_hypercall.h"
+
 static const struct ethtool_ops xennet_ethtool_ops;
 
 struct netfront_cb {
@@ -305,7 +308,7 @@
 		BUG_ON(np->rx_skbs[id]);
 		np->rx_skbs[id] = skb;
 
-		ref = gnttab_claim_grant_reference(&np->gref_rx_head);
+		ref = gnttab_claim_grant_reference_hvm(&np->gref_rx_head);
 		BUG_ON((signed short)ref < 0);
 		np->grant_rx_ref[id] = ref;
 
@@ -313,7 +316,7 @@
 		vaddr = page_address(skb_shinfo(skb)->frags[0].page);
 
 		req = RING_GET_REQUEST(&np->rx, req_prod + i);
-		gnttab_grant_foreign_access_ref(ref,
+		gnttab_grant_foreign_access_ref_hvm(ref,
 						np->xbdev->otherend_id,
 						pfn_to_mfn(pfn),
 						0);
@@ -329,7 +332,7 @@
  push:
 	RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&np->rx, notify);
 	if (notify)
-		notify_remote_via_irq(np->netdev->irq);
+		notify_remote_via_irq_hvm(np->netdev->irq);
 }
 
 static int xennet_open(struct net_device *dev)
@@ -374,16 +377,16 @@
 
 			id  = txrsp->id;
 			skb = np->tx_skbs[id].skb;
-			if (unlikely(gnttab_query_foreign_access(
+			if (unlikely(gnttab_query_foreign_access_hvm(
 				np->grant_tx_ref[id]) != 0)) {
 				printk(KERN_ALERT "xennet_tx_buf_gc: warning "
 				       "-- grant still in use by backend "
 				       "domain.\n");
 				BUG();
 			}
-			gnttab_end_foreign_access_ref(
+			gnttab_end_foreign_access_ref_hvm(
 				np->grant_tx_ref[id], GNTMAP_readonly);
-			gnttab_release_grant_reference(
+			gnttab_release_grant_reference_hvm(
 				&np->gref_tx_head, np->grant_tx_ref[id]);
 			np->grant_tx_ref[id] = GRANT_INVALID_REF;
 			add_id_to_freelist(&np->tx_skb_freelist, np->tx_skbs, id);
@@ -435,11 +438,11 @@
 		np->tx_skbs[id].skb = skb_get(skb);
 		tx = RING_GET_REQUEST(&np->tx, prod++);
 		tx->id = id;
-		ref = gnttab_claim_grant_reference(&np->gref_tx_head);
+		ref = gnttab_claim_grant_reference_hvm(&np->gref_tx_head);
 		BUG_ON((signed short)ref < 0);
 
 		mfn = virt_to_mfn(data);
-		gnttab_grant_foreign_access_ref(ref, np->xbdev->otherend_id,
+		gnttab_grant_foreign_access_ref_hvm(ref, np->xbdev->otherend_id,
 						mfn, GNTMAP_readonly);
 
 		tx->gref = np->grant_tx_ref[id] = ref;
@@ -458,11 +461,11 @@
 		np->tx_skbs[id].skb = skb_get(skb);
 		tx = RING_GET_REQUEST(&np->tx, prod++);
 		tx->id = id;
-		ref = gnttab_claim_grant_reference(&np->gref_tx_head);
+		ref = gnttab_claim_grant_reference_hvm(&np->gref_tx_head);
 		BUG_ON((signed short)ref < 0);
 
 		mfn = pfn_to_mfn(page_to_pfn(frag->page));
-		gnttab_grant_foreign_access_ref(ref, np->xbdev->otherend_id,
+		gnttab_grant_foreign_access_ref_hvm(ref, np->xbdev->otherend_id,
 						mfn, GNTMAP_readonly);
 
 		tx->gref = np->grant_tx_ref[id] = ref;
@@ -515,10 +518,10 @@
 	tx = RING_GET_REQUEST(&np->tx, i);
 
 	tx->id   = id;
-	ref = gnttab_claim_grant_reference(&np->gref_tx_head);
+	ref = gnttab_claim_grant_reference_hvm(&np->gref_tx_head);
 	BUG_ON((signed short)ref < 0);
 	mfn = virt_to_mfn(data);
-	gnttab_grant_foreign_access_ref(
+	gnttab_grant_foreign_access_ref_hvm(
 		ref, np->xbdev->otherend_id, mfn, GNTMAP_readonly);
 	tx->gref = np->grant_tx_ref[id] = ref;
 	tx->offset = offset;
@@ -561,7 +564,7 @@
 
 	RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&np->tx, notify);
 	if (notify)
-		notify_remote_via_irq(np->netdev->irq);
+		notify_remote_via_irq_hvm(np->netdev->irq);
 
 	u64_stats_update_begin(&stats->syncp);
 	stats->tx_bytes += skb->len;
@@ -693,10 +696,10 @@
 			goto next;
 		}
 
-		ret = gnttab_end_foreign_access_ref(ref, 0);
+		ret = gnttab_end_foreign_access_ref_hvm(ref, 0);
 		BUG_ON(!ret);
 
-		gnttab_release_grant_reference(&np->gref_rx_head, ref);
+		gnttab_release_grant_reference_hvm(&np->gref_rx_head, ref);
 
 		__skb_queue_tail(list, skb);
 
@@ -1094,9 +1097,9 @@
 			continue;
 
 		skb = np->tx_skbs[i].skb;
-		gnttab_end_foreign_access_ref(np->grant_tx_ref[i],
+		gnttab_end_foreign_access_ref_hvm(np->grant_tx_ref[i],
 					      GNTMAP_readonly);
-		gnttab_release_grant_reference(&np->gref_tx_head,
+		gnttab_release_grant_reference_hvm(&np->gref_tx_head,
 					       np->grant_tx_ref[i]);
 		np->grant_tx_ref[i] = GRANT_INVALID_REF;
 		add_id_to_freelist(&np->tx_skb_freelist, np->tx_skbs, i);
@@ -1130,8 +1133,8 @@
 		}
 
 		skb = np->rx_skbs[id];
-		mfn = gnttab_end_foreign_transfer_ref(ref);
-		gnttab_release_grant_reference(&np->gref_rx_head, ref);
+		mfn = gnttab_end_foreign_transfer_ref_hvm(ref);
+		gnttab_release_grant_reference_hvm(&np->gref_rx_head, ref);
 		np->grant_rx_ref[id] = GRANT_INVALID_REF;
 
 		if (0 == mfn) {
@@ -1185,8 +1188,8 @@
 	struct netfront_info *np = netdev_priv(dev);
 	xennet_release_tx_bufs(np);
 	xennet_release_rx_bufs(np);
-	gnttab_free_grant_references(np->gref_tx_head);
-	gnttab_free_grant_references(np->gref_rx_head);
+	gnttab_free_grant_references_hvm(np->gref_tx_head);
+	gnttab_free_grant_references_hvm(np->gref_rx_head);
 }
 
 static u32 xennet_fix_features(struct net_device *dev, u32 features)
@@ -1195,7 +1198,7 @@
 	int val;
 
 	if (features & NETIF_F_SG) {
-		if (xenbus_scanf(XBT_NIL, np->xbdev->otherend, "feature-sg",
+		if (xenbus_scanf_hvm(XBT_NIL, np->xbdev->otherend, "feature-sg",
 				 "%d", &val) < 0)
 			val = 0;
 
@@ -1204,7 +1207,7 @@
 	}
 
 	if (features & NETIF_F_TSO) {
-		if (xenbus_scanf(XBT_NIL, np->xbdev->otherend,
+		if (xenbus_scanf_hvm(XBT_NIL, np->xbdev->otherend,
 				 "feature-gso-tcpv4", "%d", &val) < 0)
 			val = 0;
 
@@ -1285,14 +1288,14 @@
 	}
 
 	/* A grant for every tx ring slot */
-	if (gnttab_alloc_grant_references(TX_MAX_TARGET,
+	if (gnttab_alloc_grant_references_hvm(TX_MAX_TARGET,
 					  &np->gref_tx_head) < 0) {
 		printk(KERN_ALERT "#### netfront can't alloc tx grant refs\n");
 		err = -ENOMEM;
 		goto exit_free_stats;
 	}
 	/* A grant for every rx ring slot */
-	if (gnttab_alloc_grant_references(RX_MAX_TARGET,
+	if (gnttab_alloc_grant_references_hvm(RX_MAX_TARGET,
 					  &np->gref_rx_head) < 0) {
 		printk(KERN_ALERT "#### netfront can't alloc rx grant refs\n");
 		err = -ENOMEM;
@@ -1324,7 +1327,7 @@
 	return netdev;
 
  exit_free_tx:
-	gnttab_free_grant_references(np->gref_tx_head);
+	gnttab_free_grant_references_hvm(np->gref_tx_head);
  exit_free_stats:
 	free_percpu(np->stats);
  exit:
@@ -1347,7 +1350,7 @@
 	netdev = xennet_create_dev(dev);
 	if (IS_ERR(netdev)) {
 		err = PTR_ERR(netdev);
-		xenbus_dev_fatal(dev, err, "creating netdev");
+		xenbus_dev_fatal_hvm(dev, err, "creating netdev");
 		return err;
 	}
 
@@ -1381,7 +1384,7 @@
 {
 	/* This frees the page as a side-effect */
 	if (ref != GRANT_INVALID_REF)
-		gnttab_end_foreign_access(ref, 0, (unsigned long)page);
+		gnttab_end_foreign_access_hvm(ref, 0, (unsigned long)page);
 }
 
 static void xennet_disconnect_backend(struct netfront_info *info)
@@ -1394,7 +1397,7 @@
 	spin_unlock_bh(&info->rx_lock);
 
 	if (info->netdev->irq)
-		unbind_from_irqhandler(info->netdev->irq, info->netdev);
+		unbind_from_irqhandler_hvm(info->netdev->irq, info->netdev);
 	info->evtchn = info->netdev->irq = 0;
 
 	/* End access and free the pages */
@@ -1428,7 +1431,7 @@
 	char *s, *e, *macstr;
 	int i;
 
-	macstr = s = xenbus_read(XBT_NIL, dev->nodename, "mac", NULL);
+	macstr = s = xenbus_read_hvm(XBT_NIL, dev->nodename, "mac", NULL);
 	if (IS_ERR(macstr))
 		return PTR_ERR(macstr);
 
@@ -1480,20 +1483,20 @@
 
 	err = xen_net_read_mac(dev, netdev->dev_addr);
 	if (err) {
-		xenbus_dev_fatal(dev, err, "parsing %s/mac", dev->nodename);
+		xenbus_dev_fatal_hvm(dev, err, "parsing %s/mac", dev->nodename);
 		goto fail;
 	}
 
 	txs = (struct xen_netif_tx_sring *)get_zeroed_page(GFP_NOIO | __GFP_HIGH);
 	if (!txs) {
 		err = -ENOMEM;
-		xenbus_dev_fatal(dev, err, "allocating tx ring page");
+		xenbus_dev_fatal_hvm(dev, err, "allocating tx ring page");
 		goto fail;
 	}
 	SHARED_RING_INIT(txs);
 	FRONT_RING_INIT(&info->tx, txs, PAGE_SIZE);
 
-	err = xenbus_grant_ring(dev, virt_to_mfn(txs));
+	err = xenbus_grant_ring_hvm(dev, virt_to_mfn(txs));
 	if (err < 0) {
 		free_page((unsigned long)txs);
 		goto fail;
@@ -1503,24 +1506,24 @@
 	rxs = (struct xen_netif_rx_sring *)get_zeroed_page(GFP_NOIO | __GFP_HIGH);
 	if (!rxs) {
 		err = -ENOMEM;
-		xenbus_dev_fatal(dev, err, "allocating rx ring page");
+		xenbus_dev_fatal_hvm(dev, err, "allocating rx ring page");
 		goto fail;
 	}
 	SHARED_RING_INIT(rxs);
 	FRONT_RING_INIT(&info->rx, rxs, PAGE_SIZE);
 
-	err = xenbus_grant_ring(dev, virt_to_mfn(rxs));
+	err = xenbus_grant_ring_hvm(dev, virt_to_mfn(rxs));
 	if (err < 0) {
 		free_page((unsigned long)rxs);
 		goto fail;
 	}
 	info->rx_ring_ref = err;
 
-	err = xenbus_alloc_evtchn(dev, &info->evtchn);
+	err = xenbus_alloc_evtchn_hvm(dev, &info->evtchn);
 	if (err)
 		goto fail;
 
-	err = bind_evtchn_to_irqhandler(info->evtchn, xennet_interrupt,
+	err = bind_evtchn_to_irqhandler_hvm(info->evtchn, xennet_interrupt,
 					0, netdev->name, netdev);
 	if (err < 0)
 		goto fail;
@@ -1545,69 +1548,69 @@
 		goto out;
 
 again:
-	err = xenbus_transaction_start(&xbt);
+	err = xenbus_transaction_start_hvm(&xbt);
 	if (err) {
-		xenbus_dev_fatal(dev, err, "starting transaction");
+		xenbus_dev_fatal_hvm(dev, err, "starting transaction");
 		goto destroy_ring;
 	}
 
-	err = xenbus_printf(xbt, dev->nodename, "tx-ring-ref", "%u",
+	err = xenbus_printf_hvm(xbt, dev->nodename, "tx-ring-ref", "%u",
 			    info->tx_ring_ref);
 	if (err) {
 		message = "writing tx ring-ref";
 		goto abort_transaction;
 	}
-	err = xenbus_printf(xbt, dev->nodename, "rx-ring-ref", "%u",
+	err = xenbus_printf_hvm(xbt, dev->nodename, "rx-ring-ref", "%u",
 			    info->rx_ring_ref);
 	if (err) {
 		message = "writing rx ring-ref";
 		goto abort_transaction;
 	}
-	err = xenbus_printf(xbt, dev->nodename,
+	err = xenbus_printf_hvm(xbt, dev->nodename,
 			    "event-channel", "%u", info->evtchn);
 	if (err) {
 		message = "writing event-channel";
 		goto abort_transaction;
 	}
 
-	err = xenbus_printf(xbt, dev->nodename, "request-rx-copy", "%u",
+	err = xenbus_printf_hvm(xbt, dev->nodename, "request-rx-copy", "%u",
 			    1);
 	if (err) {
 		message = "writing request-rx-copy";
 		goto abort_transaction;
 	}
 
-	err = xenbus_printf(xbt, dev->nodename, "feature-rx-notify", "%d", 1);
+	err = xenbus_printf_hvm(xbt, dev->nodename, "feature-rx-notify", "%d", 1);
 	if (err) {
 		message = "writing feature-rx-notify";
 		goto abort_transaction;
 	}
 
-	err = xenbus_printf(xbt, dev->nodename, "feature-sg", "%d", 1);
+	err = xenbus_printf_hvm(xbt, dev->nodename, "feature-sg", "%d", 1);
 	if (err) {
 		message = "writing feature-sg";
 		goto abort_transaction;
 	}
 
-	err = xenbus_printf(xbt, dev->nodename, "feature-gso-tcpv4", "%d", 1);
+	err = xenbus_printf_hvm(xbt, dev->nodename, "feature-gso-tcpv4", "%d", 1);
 	if (err) {
 		message = "writing feature-gso-tcpv4";
 		goto abort_transaction;
 	}
 
-	err = xenbus_transaction_end(xbt, 0);
+	err = xenbus_transaction_end_hvm(xbt, 0);
 	if (err) {
 		if (err == -EAGAIN)
 			goto again;
-		xenbus_dev_fatal(dev, err, "completing transaction");
+		xenbus_dev_fatal_hvm(dev, err, "completing transaction");
 		goto destroy_ring;
 	}
 
 	return 0;
 
  abort_transaction:
-	xenbus_transaction_end(xbt, 1);
-	xenbus_dev_fatal(dev, err, "%s", message);
+	xenbus_transaction_end_hvm(xbt, 1);
+	xenbus_dev_fatal_hvm(dev, err, "%s", message);
  destroy_ring:
 	xennet_disconnect_backend(info);
  out:
@@ -1623,7 +1626,7 @@
 	struct xen_netif_rx_request *req;
 	unsigned int feature_rx_copy;
 
-	err = xenbus_scanf(XBT_NIL, np->xbdev->otherend,
+	err = xenbus_scanf_hvm(XBT_NIL, np->xbdev->otherend,
 			   "feature-rx-copy", "%u", &feature_rx_copy);
 	if (err != 1)
 		feature_rx_copy = 0;
@@ -1657,7 +1660,7 @@
 		ref = np->grant_rx_ref[requeue_idx] = xennet_get_rx_ref(np, i);
 		req = RING_GET_REQUEST(&np->rx, requeue_idx);
 
-		gnttab_grant_foreign_access_ref(
+		gnttab_grant_foreign_access_ref_hvm(
 			ref, np->xbdev->otherend_id,
 			pfn_to_mfn(page_to_pfn(skb_shinfo(skb)->
 					       frags->page)),
@@ -1677,7 +1680,7 @@
 	 * packets.
 	 */
 	netif_carrier_on(np->netdev);
-	notify_remote_via_irq(np->netdev->irq);
+	notify_remote_via_irq_hvm(np->netdev->irq);
 	xennet_tx_buf_gc(dev);
 	xennet_alloc_rx_buffers(dev);
 
@@ -1696,7 +1699,7 @@
 	struct netfront_info *np = dev_get_drvdata(&dev->dev);
 	struct net_device *netdev = np->netdev;
 
-	dev_dbg(&dev->dev, "%s\n", xenbus_strstate(backend_state));
+	dev_dbg(&dev->dev, "%s\n", xenbus_strstate_hvm(backend_state));
 
 	switch (backend_state) {
 	case XenbusStateInitialising:
@@ -1713,12 +1716,12 @@
 			break;
 		if (xennet_connect(netdev) != 0)
 			break;
-		xenbus_switch_state(dev, XenbusStateConnected);
+		xenbus_switch_state_hvm(dev, XenbusStateConnected);
 		netif_notify_peers(netdev);
 		break;
 
 	case XenbusStateClosing:
-		xenbus_frontend_closed(dev);
+		xenbus_frontend_closed_hvm(dev);
 		break;
 	}
 }
@@ -1945,15 +1948,12 @@
 
 static int __init netif_init(void)
 {
-	if (!xen_domain())
-		return -ENODEV;
-
-	if (xen_initial_domain())
+	if (!xenblanket_platform)
 		return 0;
 
 	printk(KERN_INFO "Initialising Xen virtual ethernet driver.\n");
 
-	return xenbus_register_frontend(&netfront_driver);
+	return xenbus_register_frontend_hvm(&netfront_driver);
 }
 module_init(netif_init);
 
@@ -1963,11 +1963,11 @@
 	if (xen_initial_domain())
 		return;
 
-	xenbus_unregister_driver(&netfront_driver);
+	xenbus_unregister_driver_hvm(&netfront_driver);
 }
 module_exit(netif_exit);
 
 MODULE_DESCRIPTION("Xen virtual network device frontend");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("xen:vif");
-MODULE_ALIAS("xennet");
+MODULE_ALIAS("xenblanket:vif");
+MODULE_ALIAS("xenblanket_xennet");
